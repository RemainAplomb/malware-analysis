// Install boost using brew:
// brew install boost

// To compile in terminal:
// g++-13 005_Client.cpp -o client -I /opt/homebrew/Cellar/boost/1.82.0_1/include/

// To understand the topic:
// Sockets:
// Sockets are software endpoints for sending and receiving data over a network. 
// They provide a standard interface for network communication between two devices. 
// Sockets can be used for various protocols like TCP (Transmission Control Protocol) 
// and UDP (User Datagram Protocol).

// TCP (Transmission Control Protocol):
// TCP is a reliable and connection-oriented protocol that provides a reliable stream of 
// data between two devices over a network. It guarantees that data is delivered in the 
// correct order and without errors. TCP establishes a connection between the client and 
// the server before exchanging data, ensuring that all data is received and acknowledged.

// Boost Asio:
// Boost Asio is a C++ library that provides an asynchronous I/O framework for handling 
// sockets, timers, and other asynchronous operations. It simplifies network programming 
// in C++ and allows developers to write scalable and efficient networking applications. 
// Boost Asio is built on top of operating system APIs and provides a consistent interface 
// across different platforms.

#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::tcp;

int main() {
    try {
        // Initialize the Boost ASIO IO service
        // boost::asio::io_service is the core of Boost Asio, responsible for providing I/O services such 
        // as handling sockets, timers, and other asynchronous operations.
        boost::asio::io_service io_service;

        // Create a TCP socket for communication with the server
        // (tcp::socket) is created to establish the client-side of the connection with the server.
        tcp::socket socket(io_service);

        // Create a resolver to convert a query into a list of endpoints (IP address and port)
        // (tcp::resolver) is used to convert a server query (IP address and port) into a list of endpoints.
        tcp::resolver resolver(io_service);

        // Client connects to the server using one of the endpoints obtained from the resolver.
        // Basically:
        // initialize library -> initailize client-side socket -> look for another endpoint ->
        // connect to server socket -> close socket when done

        // Define the server query with the server's IP address ("localhost") and port ("8080")
        tcp::resolver::query query("localhost", "8080");

        // Get the list of endpoints (server address and port) from the resolver
        tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);

        // Connect to the server using one of the endpoints in the list
        boost::asio::connect(socket, endpoint_iterator);

        // Receive and display the welcome message from the server
        const int max_length = 4096;
        char welcomeMessage[max_length];
        size_t bytes_received = socket.read_some(boost::asio::buffer(welcomeMessage, max_length));

        std::cout << "Response from server:\n" << welcomeMessage << std::endl;

        // Start the main loop to interact with the server
        while (true) {
            // Read the user's command from the console
            std::string command;
            std::cout << "Enter a command ('shutdown-connection' to terminate): ";
            std::getline(std::cin, command);

            // Add a null terminator to the command before sending it (important for server to parse commands)
            // Always remember to add null terminator when sending
            command.push_back('\0');

            // Send the command to the server using the socket
            boost::asio::write(socket, boost::asio::buffer(command.c_str(), command.size()));

            // Receive and display the response from the server
            char response[max_length];
            bytes_received = socket.read_some(boost::asio::buffer(response, max_length));

            std::cout << "Response from server:\n" << response << std::endl;

            // Check if the server requested to terminate or refresh the connection
            if (std::string(response).find("Acknowledged: Client is terminating the connection.") != std::string::npos) {
                // Server requested to refresh the connection, so we terminate the client
                std::cout << "Exiting client." << std::endl;
                break;
            }
        }

        // Close the socket connection
        socket.close();
    } catch (std::exception& e) {
        // Handle any exceptions that might occur during execution
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    return 0;
}
