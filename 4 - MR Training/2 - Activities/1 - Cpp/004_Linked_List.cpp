#include <iostream>
#include <string>
#include <sstream>
#include <regex> // Include regex library for pattern matching

class Node
{
public:
    // Variables to store schedule information
    std::string schedule_task; // The title or task of the schedule
    std::string starting_time; // The starting time of the schedule
    std::string ending_time;   // The ending time of the schedule
    Node *next;                // A pointer to the next Node in the linked list

    // Constructor to initialize a new Node with schedule_task, starting_time, and ending_time
    // Syntax:
    // {constructor_name} ({input_data_type} {input_variable_name}, ... , {input_data_type_N} {input_variable_name_N})
    // {colon_to_indicate_initialization_to_be_executed} {things_to_initialize}
    Node(const std::string &task, const std::string &start_time, const std::string &end_time)
        : schedule_task(task), starting_time(start_time), ending_time(end_time), next(nullptr)
    {
        // When a Node object is created, its schedule_task, starting_time, and ending_time are set using the provided arguments.
        // The 'next' pointer is initialized to nullptr, indicating that the Node is not part of a linked list yet.

        // The constructor is a special member function that is automatically called when an object of the class is created.
        // In this case, the constructor takes three arguments of type 'const std::string&': 'task', 'start_time', and 'end_time'.
        // The 'const' qualifier indicates that the referenced strings will not be modified within the constructor.

        // The member initialization list (after the colon) is used to initialize member variables of the class before the constructor body executes.
        // The member initialization list is preferred here for initializing the member variables because it is more efficient.
        // Using the member initialization list avoids creating temporary objects and making extra copies.

        // schedule_task(task): This initializes the 'schedule_task' member with the value of the 'task' argument.
        // starting_time(start_time): This initializes the 'starting_time' member with the value of the 'start_time' argument.
        // ending_time(end_time): This initializes the 'ending_time' member with the value of the 'end_time' argument.
        // next(nullptr): This initializes the 'next' pointer with nullptr, indicating that the Node is not yet linked to another Node.
    }

    // Destructor to clean up memory when a Node is deleted
    // The tilde (~) before the class name indicates that this is the destructor for the class.
    // Syntax:
    // ~{destructor_name}()
    // {tilde_before_class_name} {destructor_name}()
    ~Node()
    {
        // When a Node is deleted (e.g., when it goes out of scope or is explicitly deleted), the destructor is called.
        // The destructor is responsible for releasing any dynamically allocated memory used by the Node.
        // In this case, since the Node does not have any dynamic memory allocation, there is nothing to do here.
        // However, if the Node had any dynamically allocated memory (e.g., if 'next' was allocated using 'new'), it should be deleted here to avoid memory leaks.

        // The destructor is a special member function that is automatically called when an object of the class is destroyed or goes out of scope.
        // It is responsible for releasing any resources or memory allocated by the object.

        // In this specific case, the destructor does not require any explicit memory deallocation because the Node class does not perform any dynamic memory allocation.
    }
};

class Scheduler
{
private:
    // Syntax:
    // {class_name} *{variable_name_we_want_it_to_be_initialized_with}
    Node *head; // A pointer to the first Node in the linked list

public:
    // Constructor to create a Scheduler object
    // Syntax:
    // {constructor_name}()
    // {constructor_name}() : {member_variable_name}({initial_value})
    Scheduler() : head(nullptr)
    {
        // When a Scheduler object is created, the 'head' pointer is initialized to nullptr, indicating an empty linked list.

        // The constructor is a special member function that is automatically called when an object of the class is created.
        // In this case, the constructor initializes the 'head' pointer to nullptr using the member initialization list.
        // This ensures that the linked list starts as empty when the Scheduler object is created.
    }

    // Helper function to validate the time format (HH:MM AM/PM)
    bool isValidTimeFormat(const std::string &timeStr)
    {
        // Regular expression pattern for valid time format (HH:MM AM/PM)
        // So the part encapsulated within [] is the dynamic part while those outside of it are static.
        // The dynamic part can be a range or a series of characters
        std::regex pattern(R"((1[0-2]|0?[1-9]):([0-5][0-9]) ([APap][Mm]))");
        return std::regex_match(timeStr, pattern);
    }

    // Function to remove leading and trailing whitespaces from a string
    void trimString(std::string &str)
    {
        // Find the first non-whitespace character from the beginning
        size_t start = str.find_first_not_of(" \t\n\r\f\v");
        // Find the last non-whitespace character from the end
        size_t end = str.find_last_not_of(" \t\n\r\f\v");

        // If the string is empty or contains only whitespaces, start and end will be std::string::npos
        if (start == std::string::npos || end == std::string::npos)
        {
            str.clear(); // Clear the string (it becomes empty)
        }
        else
        {
            // Update the string with the trimmed substring
            str = str.substr(start, end - start + 1);
        }
    }

    // Method to add a new schedule to the Scheduler
    // Syntax:
    // {return_type} {method_name}({input_data_type} {input_variable_name}, ... , {input_data_type_N} {input_variable_name_N})
    void addSchedule(std::string task, std::string start_time, std::string end_time)
    {
        // Trim task, start_time, and end_time
        trimString(task);
        trimString(start_time);
        trimString(end_time);

        // Check if the task already exists in the Scheduler
        if (searchSchedule(task))
        {
            std::cout << "Task '" << task << "' already exists. Added Task Failed: " << task << std::endl;
            return;
        }

        // Validate the start_time and end_time formats
        if (!isValidTimeFormat(start_time) || !isValidTimeFormat(end_time))
        {
            std::cout << "Invalid time format. Time should be in HH:MM AM/PM format. Added Task Failed: " << task << std::endl;
            return;
        }

        // Convert start_time and end_time to minutes for comparison
        int start_minutes = convertToMinutes(start_time);
        int end_minutes = convertToMinutes(end_time);

        // Check if end_time is before or on start_time
        if (end_minutes <= start_minutes)
        {
            std::cout << "Invalid time range. The end time should be after the start time. Added Task Failed: " << task << std::endl;
            return;
        }

        // The addSchedule method allows adding a new schedule to the Scheduler.

        // The method takes three arguments of type 'const std::string&': 'task', 'start_time', and 'end_time'.
        // The 'const' qualifier indicates that the referenced strings will not be modified within the method.

        // The method creates a new Node to represent the schedule using the provided task, start_time, and end_time.
        Node *new_schedule = new Node(task, start_time, end_time);

        if (head == nullptr)
        {
            // If the Scheduler is empty (head is nullptr), the new_schedule becomes the first Node in the linked list (head).
            head = new_schedule;
        }
        else
        {
            // If the Scheduler is not empty, the new_schedule is added at the end of the linked list.
            Node *current = head;
            while (current->next != nullptr)
            {
                // Traverse the linked list until the last Node is reached (current->next == nullptr).
                // The -> operator is used to access the member variables or methods of an object through a pointer.
                // {local_variable_pointer_to_certain_node_object} = {local_variable_pointer_to_certain_node_object} -> {variable_within_node_object}
                current = current->next;
            }
            // Add the new_schedule as the next Node after the last Node in the linked list.
            current->next = new_schedule;
        }

        std::cout << "Successfully added task: " << task << std::endl;
    }

    // Function to display all the schedules in the linked list
    void displaySchedules()
    {
        // Declare a local pointer variable 'current' of type Node* and initialize it with the address of the head node
        Node *current = head;

        // Start a loop that iterates through the linked list until the 'current' pointer becomes nullptr
        while (current != nullptr)
        {
            // Print the details of the current schedule
            std::cout << "Task: " << current->schedule_task << ", Start Time: " << current->starting_time
                      << ", End Time: " << current->ending_time << std::endl;

            // Move the 'current' pointer to the next node in the linked list
            current = current->next;
        }
    }

    // Function to delete a schedule with a specific task from the linked list
    // A void function for deleting schedule, it will take in a reference to a string variable
    // and make it a constant so that it will not be modifiable within the local scope of this
    // function.
    void deleteSchedule(std::string task)
    {
        // Remove Whitespaces of task
        trimString(task);

        // Declare two local pointer variables 'current' and 'prev' of type Node* and initialize 'current' with the address of the head node and 'prev' with nullptr
        Node *current = head;
        Node *prev = nullptr;

        // Start a loop that iterates through the linked list until the 'current' pointer becomes nullptr
        while (current != nullptr)
        {
            // Check if the 'schedule_task' of the current node matches the input 'task'
            if (current->schedule_task == task)
            {
                // If the 'schedule_task' matches the input 'task', it means the schedule is found.

                // Check if the 'current' node is the head node (i.e., the first node in the linked list)
                if (prev == nullptr)
                {
                    // If 'current' is the head node, update 'head' to point to the next node in the linked list (the second node)
                    head = current->next;
                }
                else
                {
                    // If 'current' is not the head node, update the 'next' pointer of the previous node to skip 'current' and point to the next node
                    prev->next = current->next;
                }

                // Delete the 'current' node to free the memory associated with it
                delete current;

                std::cout << "Schedule with task '" << task << "' has been deleted." << std::endl;

                // Exit the function as the schedule has been found and deleted
                return;
            }

            // Move 'prev' to the current node, and 'current' to the next node in the linked list to continue the search
            prev = current;
            current = current->next;
        }

        // If the loop completes without finding the schedule, it means the schedule with the given task does not exist in the linked list.
        // Display a message to indicate that the schedule was not found.
        std::cout << "Schedule with task '" << task << "' not found." << std::endl;
    }

    // Function to count the number of schedules in the linked list
    int countSchedules()
    {
        // Declare a local variable 'count' and initialize it to 0
        int count = 0;

        // Declare a local pointer variable 'current' of type Node* and initialize it with the address of the head node
        Node *current = head;

        // Start a loop that iterates through the linked list until the 'current' pointer becomes nullptr
        while (current != nullptr)
        {
            // Increment the 'count' variable to keep track of the number of nodes encountered
            count++;

            // Move 'current' to the next node in the linked list to continue the count
            current = current->next;
        }

        // After the loop, 'current' is nullptr, indicating that we have reached the end of the linked list.
        // The 'count' variable now holds the total number of nodes encountered, which is the number of schedules in the linked list.

        // Return the count of schedules
        return count;
    }

    // Function to search for a schedule with a specific task in the linked list
    bool searchSchedule(std::string task)
    {
        // Delete whitespaces of task
        trimString(task);

        // Declare a local pointer variable 'current' of type Node* and initialize it with the address of the head node
        Node *current = head;

        // Start a loop that iterates through the linked list until the 'current' pointer becomes nullptr
        while (current != nullptr)
        {
            // Check if the 'schedule_task' of the current node matches the input 'task'
            if (current->schedule_task == task)
            {
                // If a schedule with the specified task is found, return true
                return true;
            }

            // Move 'current' to the next node in the linked list to continue the search
            current = current->next;
        }

        // After the loop, 'current' is nullptr, indicating that we have reached the end of the linked list.
        // If the loop did not return true earlier, it means that the specified task was not found in the linked list.
        // Return false to indicate that the schedule with the specified task was not found.
        return false;
    }

    // Function to convert time strings to minutes for comparison
    int convertToMinutes(const std::string &timeStr)
    {
        // Declare local variables to store the parsed hours, minutes, and meridian (AM/PM)
        int hours, minutes;
        char meridian;

        // Create an input string stream (std::istringstream) initialized with the input timeStr
        // This line creates an input string stream (std::istringstream) called iss and initializes it
        // with the input timeStr. The istringstream class is used to extract formatted data from strings,
        // and in this case, it allows us to easily extract the hours, minutes, and meridian from the input time string.
        std::istringstream iss(timeStr);

        // Extract the hours, minutes, and meridian from the input timeStr using the input string stream (iss)
        // For numeric types (like int), the >> operator reads characters from the input stream until it finds a
        // non-digit character (e.g., whitespace, punctuation, or a character that cannot be part of a number)
        // To understand better, here's an example:
        // If the input stream contains "10:30 AM," iss >> hours; will read "10" and store it in the hours variable.
        // If the input stream contains "05:45 PM," iss >> hours; will read "05" and store it in the hours variable.
        // If the input stream contains "1:15 PM," iss >> hours; will read "1" and store it in the hours variable
        iss >> hours;
        // Ignore the ':' separator between hours and minutes
        iss.ignore();
        iss >> minutes;
        iss >> meridian;

        // Convert the time to a 24-hour format if the meridian is 'P' (PM) or 'p' (pm)
        if (meridian == 'P' || meridian == 'p')
        {
            if (hours != 12)
            {
                // Add 12 to the hours (except when it's 12 PM)
                hours += 12;
            }
        }
        else // The meridian is 'A' (AM) or 'a' (am)
        {
            if (hours == 12)
            {
                // Convert 12 AM to 0 (midnight)
                hours = 0;
            }
        }

        // Calculate the total minutes from the converted hours and minutes
        return hours * 60 + minutes;
    }

    // Function to sort the schedules based on starting time or schedule task (task name)
    void sortSchedules(bool sortByStartTime)
    {
        // If the list is empty or has only one element, it is already sorted (base case)
        if (head == nullptr || head->next == nullptr)
        {
            return;
        }

        // Variables to control the sorting process
        // Flag 'swapped' is initialized to false at the beginning of each iteration.
        // If any swaps occur during the iteration, the flag will be set to true, and the
        // loop will continue for another iteration.
        bool swapped;

        // Two pointers current and last are used to traverse the linked list and identify
        // the unsorted portion of the list. current points to the current schedule being
        // compared, and last points to the last compared pair in each iteration.
        Node *current;
        Node *last = nullptr;

        // Perform bubble sort until the list is sorted
        do
        {
            swapped = false; // Initialize swapped to false for each iteration
            current = head;  // Start from the beginning of the list

            // Iterate through the unsorted part of the list
            while (current->next != last)
            {
                int time1 = convertToMinutes(current->starting_time);
                int time2 = convertToMinutes(current->next->starting_time);

                // Compare the current schedule's starting time with the next schedule's starting time
                // If the sorting condition is met, swap the schedules (bubble up the larger element)
                if ((sortByStartTime && time1 > time2) ||
                    (!sortByStartTime && current->schedule_task > current->next->schedule_task))
                {
                    // Swap the variables between the two nodes
                    std::swap(current->schedule_task, current->next->schedule_task);
                    std::swap(current->starting_time, current->next->starting_time);
                    std::swap(current->ending_time, current->next->ending_time);
                    swapped = true; // Set swapped to true, indicating a swap occurred in this iteration
                }

                current = current->next; // Move to the next pair of schedules
            }

            last = current; // The last is now the last compared pair in this iteration
        } while (swapped);  // Continue the loop if any swaps occurred in the last iteration (list is not fully sorted)
    }

    // Destructor for the Scheduler class
    ~Scheduler()
    {
        // Start from the beginning of the linked list (head)
        Node *current = head;

        // Traverse the linked list and delete each Node
        while (current != nullptr)
        {
            // Save the next Node's address before deleting the current Node
            Node *next = current->next;

            // Delete the current Node (free memory)
            delete current;

            // Move to the next Node
            current = next;
        }
    }
};

int main()
{
    Scheduler scheduler;

    // Add schedule and testing removal of trailing whitespaces
    scheduler.addSchedule("  Lunch", "12:00 PM", "01:00 PM");
    scheduler.addSchedule("Meeting   ", "10:00 AM", "11:30 AM");
    scheduler.addSchedule("Work out", "03:30 PM", "04:30 PM");
    scheduler.addSchedule("Dinner", "07:00 PM", "08:00 PM");

    std::cout << "\n============ CURRENT SCHEDULES ============\n";
    scheduler.displaySchedules();
    std::cout << "=============================================\n\n";

    int choice;
    std::string task, start_time, end_time, search_task, delete_task;

    while (true)
    {
        std::cout << "\n========== SCHEDULE MANAGEMENT MENU ==========\n";
        std::cout << "1. Add Schedule\n";
        std::cout << "2. Count Schedules\n";
        std::cout << "3. Display Schedules\n";
        std::cout << "4. Sort Schedules\n";
        std::cout << "5. Search Schedule\n";
        std::cout << "6. Delete Schedule\n";
        std::cout << "7. Exit\n";
        std::cout << "Enter your choice (1-7): ";
        std::cin >> choice;
        std::cout << "=============================================\n\n";

        // Check if the input is valid
        if (std::cin.fail())
        {
            std::cin.clear();                                                   // Clear the error state
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Ignore remaining characters in the buffer
            std::cout << "Invalid input. Please enter a number (1-7).\n";
            continue; // Ask the user to enter the choice again
        }

        switch (choice)
        {
        case 1:
            std::cout << "Enter Task: ";
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            std::getline(std::cin, task);
            std::cout << "Enter Start Time (HH:MM AM/PM): ";
            std::getline(std::cin, start_time);
            std::cout << "Enter End Time (HH:MM AM/PM): ";
            std::getline(std::cin, end_time);
            scheduler.addSchedule(task, start_time, end_time);
            break;
        case 2:
            std::cout << "Total Schedules: " << scheduler.countSchedules() << std::endl;
            break;
        case 3:
            std::cout << "Current Schedules:" << std::endl;
            scheduler.displaySchedules();
            break;
        case 4:
            std::cout << "Sort by Starting Time (1) or Schedule Task (2)? Enter 1 or 2: ";
            int sortChoice;
            std::cin >> sortChoice;

            if (std::cin.fail())
            {
                std::cin.clear();                                                   // Clear the error state
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Ignore remaining characters in the buffer
                std::cout << "Invalid input. Please enter a number (1-2).\n";
                continue; // Ask the user to enter the choice again
            }

            switch (sortChoice)
            {
            case 1:
                scheduler.sortSchedules(true);
                std::cout << "Schedules sorted by starting time." << std::endl;
                break;
            case 2:
                scheduler.sortSchedules(false);
                std::cout << "Schedules sorted by task." << std::endl;
                break;
            default:
                std::cout << "Invalid sort choice. Please enter 1 or 2." << std::endl;
                break;
            }
            break;
        case 5:
            std::cout << "Enter Task to Search: ";
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            std::getline(std::cin, search_task);
            scheduler.trimString(search_task);
            if (scheduler.searchSchedule(search_task))
            {
                std::cout << "Schedule '" << search_task << "' found." << std::endl;
            }
            else
            {
                std::cout << "Schedule '" << search_task << "' not found." << std::endl;
            }
            break;
        case 6:
            std::cout << "Enter Task to Delete: ";
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            std::getline(std::cin, delete_task);
            scheduler.trimString(delete_task);
            scheduler.deleteSchedule(delete_task);
            break;
        case 7:
            std::cout << "Exiting the program. Goodbye!\n";
            return 0;
        default:
            std::cout << "Invalid choice. Please try again.\n";
            break;
        }
    }

    return 0;
}
