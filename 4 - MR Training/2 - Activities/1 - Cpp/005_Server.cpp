// Install boost using brew:
// brew install boost

// To compile in terminal:
// {compiler (i.e. gcc/clang/g++)} {file_name}.cpp -o {exe_filename}
// g++-13 005_Server.cpp -o server -I /opt/homebrew/Cellar/boost/1.82.0_1/include/

// To understand the topic:
// Sockets:
// Sockets are software endpoints for sending and receiving data over a network. 
// They provide a standard interface for network communication between two devices. 
// Sockets can be used for various protocols like TCP (Transmission Control Protocol) 
// and UDP (User Datagram Protocol).

// TCP (Transmission Control Protocol):
// TCP is a reliable and connection-oriented protocol that provides a reliable stream of 
// data between two devices over a network. It guarantees that data is delivered in the 
// correct order and without errors. TCP establishes a connection between the client and 
// the server before exchanging data, ensuring that all data is received and acknowledged.

// Boost Asio:
// Boost Asio is a C++ library that provides an asynchronous I/O framework for handling 
// sockets, timers, and other asynchronous operations. It simplifies network programming 
// in C++ and allows developers to write scalable and efficient networking applications. 
// Boost Asio is built on top of operating system APIs and provides a consistent interface 
// across different platforms.

#include <iostream>
#include <boost/asio.hpp>
#include <unistd.h> // For chdir function

using boost::asio::ip::tcp;

// Function to execute the client's command and provide the server's response
std::string executeCommand(const std::string& command) {
    if (command == "rock" || command == "paper" || command == "scissors") {
        // Play a simple Rock-Paper-Scissors game against the server
        std::string choices[3] = {"rock", "paper", "scissors"};
        std::string serverChoice = choices[rand() % 3];

        if (command == serverChoice) {
            return "Tie! Both chose " + command + ".";
        } else if ((command == "rock" && serverChoice == "scissors") ||
                   (command == "paper" && serverChoice == "rock") ||
                   (command == "scissors" && serverChoice == "paper")) {
            return "You win! You chose " + command + ", and the server chose " + serverChoice + ".";
        } else {
            return "You lose! You chose " + command + ", and the server chose " + serverChoice + ".";
        }
    } else if (command == "shutdown-connection") {
        return "Acknowledged: Client is terminating the connection.";
    } else if (command == "get-server-info") {
        return "Server information: OS - macOS, Version - 1.0";
    } else {
        return "Invalid command. Try 'rock', 'paper', or 'scissors'.";
    }
}

int main() {
    try {
        const int max_length = 4096;
        
        // Initialize the Boost ASIO IO service
        boost::asio::io_service io_service;

        // Create a TCP acceptor to listen for incoming connections on port 8080
        // (tcp::acceptor) is for listening for incoming connections from clients.
        // three-way handshake:
        // SYN - user to server
        // SYN-ACK - server to user
        // ACK - user to server
        tcp::acceptor acceptor(io_service, tcp::endpoint(tcp::v4(), 8080));

        std::cout << "Server is running. Waiting for connections..." << std::endl;

        // Main loop to accept and handle client connections
        while (true) {
            // Create a new socket to handle the connection with the client
            tcp::socket socket(io_service);

            // Wait for a client
            // Once there's a client, accept it.
            acceptor.accept(socket);

            // Send the welcome message to the client
            std::string welcomeMessage = "Connected to server. This is a Rock-Paper-Scissors game. Enter 'rock', 'paper', or 'scissors' as a command.";
            welcomeMessage.push_back('\0'); // Null terminator to specify end of welcome message
            boost::asio::write(socket, boost::asio::buffer(welcomeMessage));

            std::cout << "Client connected." << std::endl;

            // Keep the connection open and allow the client to send multiple commands
            while (true) {
                // Read the command sent by the client
                char command[max_length];
                size_t bytes_received = socket.read_some(boost::asio::buffer(command));

                // command = "scissors?-?"
                // 

                std::cout << "Command received: " << command << std::endl;

                // Execute the client's command and get the server's response
                std::string response = executeCommand(command);

                // Send the response back to the client
                // Add null terminator before sending response
                // If we don't, there'll be problems with parsing the response
                // once it was received by the client
                response.push_back('\0');
                boost::asio::write(socket, boost::asio::buffer(response));

                // Check if the server requested to terminate or refresh the connection
                if (response == "Acknowledged: Client is terminating the connection.") {
                    socket.close();
                    break;
                }
            }
        }
    } catch (std::exception& e) {
        // Handle any exceptions that might occur during execution
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    return 0;
}