; Remove Leading and Trailing White Spaces
format PE Console
entry main

include 'win32ax.inc'

; Define constants and data
section '.data' data readable writeable
    prompt_msg db "Enter a string: ",0 ; Prompt
    prompt_len = $ - prompt_msg         ; The length of the prompt

    input_buffer db 256 dup(0)          ; Buffer to hold user input (max 256 characters)
    bytes_read dd ?                     ; For stdin

    bytes_written dd ?                  ; for stdout
    stdout dd ?                         ; Will contain the handler for stdout
    stdin dd ?                          ; Will contain the handler for stdin

; Main code section
section '.text' code readable executable

main:
    ; Initialize stdout and stdin
    invoke GetStdHandle, STD_OUTPUT_HANDLE
    mov [stdout], eax

    invoke GetStdHandle, STD_INPUT_HANDLE
    mov [stdin], eax

    ; Prompt the user for input
    ; Syntax:
    ; invoke {function}, [{variable_pointer}], {variable_to_print_or_ask}, {size_to_print_or_ask}, {bytes_read_or_written}, 0
    invoke WriteConsoleA, [stdout], prompt_msg, prompt_len, bytes_written, 0
    invoke ReadConsoleA, [stdin], input_buffer, 255, bytes_read, 0  ; read up to 255 characters

    ; Remove the CR and LF from the end of the string
    ; sub [bytes_read], 2
    ; mov byte [input_buffer + eax - 2], 0

    ; Call the function to strip leading and trailing white spaces
    call strip_whitespaces

    ; Now, print using the number of characters that were read
    invoke WriteConsoleA, [stdout], input_buffer, [bytes_read], bytes_written, 0

exit_program:
    ; Exit the program
    invoke ExitProcess, 0

; Function to strip leading and trailing white spaces (spaces, tabs, CR, LF)
; strip whitespace -> strip leading whitespace -> 
strip_whitespaces:
    lea esi, [input_buffer]         ; Use register esi as pointer for the leading whitespace loop
    lea edi, [input_buffer]         ; Use register edi as pointer for the trailing whitespace loop

.skip_leading:
    ; Check for white space characters at the beginning
    cmp byte [esi], ' '             ; Space. Check if current byte pointed by esi is a whitespace
    je .skip_char                   ; If it is whitespace, go to .skip_char so that we will not copy it to the eax
    cmp byte [esi], 9               ; tab
    je .skip_char
    cmp byte [esi], 10              ; LF
    je .skip_char
    cmp byte [esi], 13              ; CR
    je .skip_char
    jmp .copy_chars                 ; If current byte is not whitespace, we have found the start of string

.skip_char:
    ; Move to the next character
    inc esi                         ; If whitespace, increment to the next byte
    dec [bytes_read]                ; Subtract number of bytes from bytes_read. 
    jmp .skip_leading               ; Go back to the skip leading loop

.copy_chars:
    ; Copy characters from esi to edi until a null byte is encountered
    movzx eax, byte [esi]           ; Copy the value of the current byte pointed by esi
    test eax, eax                   ; Check whether it is not the Null terminator
    jz .end_of_string               ; If null terminator, go to .end_of_string
    mov [edi], al                   ; Overwrite the leading whitespace character byte with a non-white space character
    inc edi                         ; Increment the edi counter to point to the next byte
    inc esi                         ; Increment the edi counter to point to the next byte
    jmp .copy_chars                 ; Keep the loop going to copy the entire string

.end_of_string:
    ; Append null terminator
    mov [edi], al                   ; Append/copy/move the null-terminator to the end of the string

    ; Now, let's strip trailing whitespaces
    dec edi                         ; Decrement to point to the byte before the null-terminator

.strip_trailing:
    ; Check for white space characters at the end
    cmp byte [edi], ' '             ; space. IF whitespace, go to .strip_trailing_char
    je .strip_trailing_char
    cmp byte [edi], 9               ; tab
    je .strip_trailing_char
    cmp byte [edi], 10              ; LF
    je .strip_trailing_char
    cmp byte [edi], 13              ; CR
    je .strip_trailing_char
    ret                             ; If found non-whitespace character, end the loop

.strip_trailing_char:
    ; Replace character with null
    mov byte [edi], 0               ; Overwrite current byte pointed by edi to 0
    dec [bytes_read]                ; Subtract bytes_read by 1 because we have removed a whitespace
    dec edi                         ; Decrement to point to the byte before the current byte
    jmp .strip_trailing             ; Go back to loop



; Import section
section '.idata' data readable import
    library kernel32, 'kernel32.dll'
    
    import kernel32, \
        GetStdHandle, 'GetStdHandle', \
        WriteConsoleA, 'WriteConsoleA', \
        ReadConsoleA, 'ReadConsoleA', \
        ExitProcess, 'ExitProcess'