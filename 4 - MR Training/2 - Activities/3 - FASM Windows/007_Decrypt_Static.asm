; Encrypt FASM code

format PE Console
entry main

include 'win32a.inc'

section '.data' data readable writeable
    static_key db 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10
    MS_ENH_RSA_AES_PROV db "Microsoft Enhanced RSA and AES Cryptographic Provider", 0
    MS_ENHANCED_PROV db "Microsoft Enhanced Cryptographic Provider v1.0", 0

    target_file db "sample.asm.ODMUA", 0
    encrypted_target_file db "decrypted_sample.asm.ODMUA", 0

    target_file_handle dd ?
    encrypted_target_file_handle dd ?

    stdout dd ?
    bytes_read dd ?
    bytes_written dd ?

    mbox_title db "Notification", 0                                 ; Title of the messagebox
    file_open_success db "File opened successfully!", 0             ; Prompt for opening txt file succesfully
    file_write_success db "File written successfully!", 0           ; Prompt for writing to file successfully
    program_success db "Program executed successfully", 0

    file_open_fail db "Failed to open the file.", 0                 ; Prompt for failing to open file
    read_file_fail db "Failed to read the file.", 0                 ; Prompt for failing to read the file
    file_size_fail db "Failed to get the file size.", 0             ; Prompt for failing to get the file size

    skey_acquire_fail db "Failed to acquire session key.", 0        ; Prompt for failing to acquire session key
    create_hash_fail db "Failed to create hash.", 0                 ; Prompt for failing to create hash.
    crypt_hash_fail db "Failed crypt hash data.", 0                 ; Prompt for failing crypt hash data
    derive_key_fail db "Failed to derive key.", 0                   ; Prompt for failing to derive key

    decryption_fail db "Decryption failed.", 0                      ; Prompt for failing the decryption process

    hXchgKey dd 0
    hUserKey dd ?
    
    provider_handle dd ?
    hkey_handle dd ?
    hash_handle dd ?

    buffer_size dd ?
    buffer rb 8192

section '.code' code readable executable
main:
    ; Initialize stdout and stdin
    push -11                                                        ; STD_OUTPUT_HANDLE = -11
    call [GetStdHandle]
    mov [stdout], eax

    ; Acquire cryptographic context
    push 0                                                          ; dwFlags
    push 0x00000018                                                 ; dwProvType. PROV_RSA_FULL = 1. PROV_RSA_AES =24
    push MS_ENH_RSA_AES_PROV                                        ; szProvider
    push 0                                                          ; szContainer
    lea eax, [provider_handle]
    push eax                                                        ; *phProv = provider handle
    call [CryptAcquireContextA]

    ; Return if eax is not zero.
    test eax, eax
    jz skey_acquire_error

    ; Create the hash
    lea eax, [hash_handle]
    push eax                                                        ; *phHash = provider hash handle
    push 0                                                          ; dwFlags. CRYPT_SECRETDIGEST = 0x00000001
    push 0                                                          ; hKey (no hKey yet)
    push 0x00008003                                                 ; Algid. CALG_RC4 = 0x00006801
    push [provider_handle]                                          ; phProv = provider handle
    call [CryptCreateHash]

    ; Return if eax is not zero.
    test eax, eax
    jz create_hash_error

    ; Hash Data
    push 0                                                          ; dwFlags
    push 16                                                         ; dwDataLen
    lea eax, [static_key]
    push eax                                                        ; *pbData
    push [hash_handle]                                              ; hHash
    call [CryptHashData]

    ; Return if eax is not zero.
    test eax, eax
    jz crypt_hash_error

    ; Derive key 
    lea eax, [hkey_handle]
    push eax                                                        ; *phKey. A pointer to a HCRYPTKEY variable to receive the address of the handle of the newly generated key.
    push 0                                                 ; dwFlags. CRYPT_EXPORTABLE = 0x00000001
    push [hash_handle]                                              ; hBaseData
    push 0x00006801                                                 ; Algid. CALG_RC4 = 0x00006801
    push [provider_handle]                                          ; phProv = provider handle
    call [CryptDeriveKey]

    ; Return if eax is not zero.
    test eax, eax
    jz derive_key_error

    ; Create/Open Target file
    ; Open the file, read its content into a buffer
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 3                                                          ; dwCreationDisposition
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push target_file                                                ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [target_file_handle], eax                                   ; Store file handle

    ; Return if eax is not zero.
    test eax, eax
    jz create_file_error

    ; Read content from the file
    ;invoke  ReadFile, [target_file_handle], buffer, [buffer_size], bytes_read, 0
    push 0                                                          ; lpOverlapped
    push bytes_read                                                 ; lpNumberOfBytesRead
    push 8192                                              ; nNumberOfBytesToRead
    push buffer                                                   ; lpBuffer
    push [target_file_handle]                                                        ; file handle
    call [ReadFile]                                                 ; ReadFile Function

    ; Return if eax is not zero.
    test eax, eax
    jz read_file_error

    ; Close file handle
    push [target_file_handle]
    call [CloseHandle]

    ; Decrypt the buffer
    ;push 8192                                                  ; dwBufLen
    push bytes_read                                           ; pdwDataLen
    lea eax, [buffer]
    push eax                                                  ; pbData
    push 0                                                    ; dwFlags
    push 1                                                    ; Final
    push 0                                                    ; hHash
    push [hkey_handle]
    call [CryptDecrypt]                                      ; Use CryptDecrypt instead of CryptEncrypt

    ; Return if eax is not zero.
    test eax, eax
    jz crypt_decrypt_error                                   ; Handle decryption error

    ; Print in console
    push 0
    push bytes_written
    push [bytes_read]
    push buffer
    push [stdout]
    call [WriteConsoleA]

    ; Create encrypted file
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 2                                                          ; dwCreationDisposition. CREATE_ALWAYS = 2
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push encrypted_target_file                                      ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [encrypted_target_file_handle], eax                                   ; Store file handle

    push 0                                                          ; lpOverlapped
    push bytes_written                                              ; lpNumberOfBytesWritten    
    push [bytes_read]                                               ; nNumberOfBytesToWrite
    push buffer                                                     ; lpBuffer
    push [encrypted_target_file_handle]                                       ; file handle
    call [WriteFile]


    ; Read file contents
    ; mov eax, [encrypted_target_file_handle] ; not needed, eax already contains handle
    ;mov edx, [bytes_read]
    ;call write_file

    ; Close file handle
    push [encrypted_target_file_handle]
    call [CloseHandle]

    mov eax, program_success
    call message_box


; For exiting the program
close_program:
    push 0
    call [ExitProcess]

execute_return:
    ret

; For displaying messageboxes
; It expects value in eax for the content of the messagebox
message_box:
    push 0                                                          ; Type of message box: MB_OK
    push mbox_title
    push eax
    push 0                                                          ; Handle to owner window
    call [MessageBoxA]
    ret

skey_acquire_error:
    mov eax, skey_acquire_fail
    call message_box
    jmp close_program

create_hash_error:
    mov eax, create_hash_fail
    call message_box
    jmp close_program

crypt_hash_error:
    mov eax, crypt_hash_fail
    call message_box
    jmp close_program

derive_key_error:
    mov eax, derive_key_fail
    call message_box
    jmp close_program

create_file_error:
    mov eax, file_open_fail
    call message_box
    jmp close_program

get_file_size:
    push 0
    push eax
    call [GetFileSize]

    ; Return if eax is not zero.
    test eax, eax
    jnz execute_return

    mov eax, file_size_fail
    call message_box
    jmp close_program

read_file_error:
    mov eax, read_file_fail
    call message_box
    jmp close_program

; Expects
; eax: file handle
; edx: The size of the buffer
; buffer: contains the pointer to the string that will be printed
; bytes_written: contains the pointer to the number of bytes that will be written
write_file:
    push 0                                                          ; lpOverlapped
    push bytes_written                                              ; lpNumberOfBytesWritten    
    push edx                                               ; nNumberOfBytesToWrite
    push buffer                                                     ; lpBuffer
    push eax                                       ; file handle
    call [WriteFile]

crypt_decrypt_error:
    mov eax, decryption_fail
    call message_box
    jmp close_program

section '.idata' import data readable
    library advapi32, 'advapi32.dll', \
            kernel32, 'kernel32.dll', \
            user32, 'user32.dll'
  
    import advapi32, \
            CryptAcquireContextA, 'CryptAcquireContextA', \
            CryptCreateHash, 'CryptCreateHash', \
            CryptHashData, 'CryptHashData', \
            CryptDeriveKey, 'CryptDeriveKey', \
            CryptDecrypt, 'CryptDecrypt', \
            CryptDestroyKey, 'CryptDestroyKey', \
            CryptDestroyHash, 'CryptDestroyHash', \
            CryptReleaseContext, 'CryptReleaseContext'
  
    import kernel32, \
        ExitProcess, 'ExitProcess', \
        GetStdHandle, 'GetStdHandle', \
        WriteConsoleA, 'WriteConsoleA', \
        ReadConsoleA, 'ReadConsoleA', \
        CreateFileA, 'CreateFileA', \
        ReadFile, 'ReadFile', \
        WriteFile, 'WriteFile', \
        GlobalAlloc, 'GlobalAlloc', \
        GetFileSize, 'GetFileSize', \
        CloseHandle, 'CloseHandle'
    
    import user32, \
       MessageBoxA, 'MessageBoxA'