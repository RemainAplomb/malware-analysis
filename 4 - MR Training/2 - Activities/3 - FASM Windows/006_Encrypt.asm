format PE Console
entry start

include 'win32a.inc'

section '.data' data readable writeable
    MS_ENH_RSA_AES_PROV db "Microsoft Enhanced RSA and AES Cryptographic Provider", 0
    MS_ENHANCED_PROV db "Microsoft Enhanced Cryptographic Provider v1.0", 0
    hXchgKey dd 0
    hUserKey dd ?

    hProv      dd ?
    hKey       dd ?
    source_file   db 'sample.asm', 0
    source_file_handle dd ?                                         ; File handle of the source file

    key_file   db 'key.txt', 0
    key_file_handle dd ?        ; File handle for the key file

    buffer     rb 4096
    stdout dd ?                                                     ; Will contain the handler for stdout
    bytes_written dd ?                                              ; for the bytes written
    bytes_read dd ?                                                 ; for the bytes read

    file_open_success db "File opened successfully!", 0             ; Prompt for opening txt file succesfully
    file_write_success db "File written successfully!", 0           ; Prompt for writing to file successfully
    file_open_fail db "Failed to open the file.", 0                 ; Prompt for failing to open file
    skey_acquire_fail db "Failed to acquire session key.", 0        ; Prompt for failing to acquire session key
    skey_generate_fail db "Failed to generate session key.", 0      ; Prompt for failing to generate session key
    encryption_fail db "Encryption failed.", 0                      ; Prompt for failing the encryption process
    user_key_fail db "Failed to get the user key.", 0               ; Prompt for failing to get the user key
    caption db "File Status", 0                                     ; Title of the messagebox

    key_blob dd 4096             ; Pointer to the blob. We'll allocate memory for this.
    key_blob_size dd 0      ; Start with an arbitrary value, adjust later

section '.code' code readable executable

start:
    ; Initialize stdout and stdin
    push -11                                                    ; STD_OUTPUT_HANDLE = -11
    call [GetStdHandle]
    mov [stdout], eax

    ; Acquire cryptographic context
    push 0                                      ; dwFlags
    push 1                                      ; dwProvType. PROV_RSA_FULL = 1. PROV_RSA_AES =24
    push MS_ENHANCED_PROV                              ; szProvider
    push NULL                                     ; szContainer
    lea eax, [hProv]
    push eax                                  ; *phProv
    call [CryptAcquireContextA]
    ;invoke CryptAcquireContextA,hProv,0,0,1,0xF0000000


    ; Check if session key is successfully acquired
    test eax, eax
    jz skey_acquire_error

    ; Generate AES-256 symmetric key
    lea eax, [hKey]        ; *phKey. Pointer to HCRYPTKEY
    push eax               ; *phKey. Pointer to HCRYPTKEY
    push 0x00800001        ; dwFlags. CRYPT_EXPORTABLE = 0x00000001. KEYLENGTH  0x00800001
    push 0x00006801        ; Algid. CALG_RC4 = 0x6801. CALG_RSA_KEYX= 0x0000a400. AT_KEYEXCHANGE = 1. CALG_AES_256 = 0x00006610
    push [hProv]
    call [CryptGenKey]

    ; Check if session key is successfully acquired
    test eax, eax
    jz skey_generate_error

    ;mov [hXchgKey], eax

    call get_user_key

    ; Open the file, read its content into a buffer
    ; For simplicity, assuming the file's size is less than 4096 bytes
    ; Here you would use CreateFile, ReadFile and other File I/O APIs
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 3                                                          ; dwCreationDisposition
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push source_file                                                ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [source_file_handle], eax                                   ; Store file handle

    ; Check if the handle is valid
    cmp eax, -1                                                     ; INVALID_HANDLE_VALUE = -1
    je file_open_error

    ; File Handle is valid
    push eax
    mov eax, file_open_success
    call message_box
    pop eax

    ; Read content from the file
    push 0                                                          ; lpOverlapped
    push bytes_read                                                 ; lpNumberOfBytesRead
    push 4096                                                       ; nNumberOfBytesToRead
    push buffer                                                     ; lpBuffer
    push [source_file_handle]                                       ; file handle
    call [ReadFile]                                                 ; ReadFile Function

    ; Close the file
    push [source_file_handle]
    call [CloseHandle]

    ; Now, print using the number of characters that were read
    push 0
    push bytes_written
    push [bytes_read]
    push buffer
    push [stdout]
    call [WriteConsoleA]

    ; Encrypt the buffer
    push 4096            ; dwBufLen
    push bytes_read      ; pdwDataLen
    lea eax, [buffer]
    push eax             ; pbData
    push 0               ; dwFlags
    push 1               ; Final
    push 0               ; hHash
    push [hKey]
    call [CryptEncrypt]

    ; Check if encryption was succesfully executed
    test eax, eax
    jz encryption_error

    ; Save the encrypted content back to the file
    ; You'd use WriteFile and other File I/O APIs
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 2                                                          ; dwCreationDisposition. CREATE_ALWAYS = 2
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push source_file                                                ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [source_file_handle], eax                                   ; Store file handle

    ; Check if the handle is valid
    cmp eax, INVALID_HANDLE_VALUE       
    je file_open_error

    ; File Handle is valid
    push eax
    mov eax, file_open_success
    call message_box
    pop eax

    push 0                                                          ; lpOverlapped
    push bytes_written                                              ; lpNumberOfBytesWritten    
    push [bytes_read]                                               ; nNumberOfBytesToWrite
    push buffer                                                     ; lpBuffer
    push [source_file_handle]                                       ; file handle
    call [WriteFile]

    ; File write success
    push eax
    mov eax, file_write_success
    call message_box
    pop eax

    ; Close the file
    push [source_file_handle]
    call [CloseHandle]

    ; Cleanup
    push [hKey]
    call [CryptDestroyKey]

    push [hProv]
    call [CryptReleaseContext]

; For exiting the program
close_program:
    push 0
    call [ExitProcess]

; For displaying messageboxes
; It expects value in eax for the content of the messagebox
message_box:
    push 0                              ; Type of message box: MB_OK
    push caption
    push eax
    push 0                              ; Handle to owner window
    call [MessageBoxA]
    ret

; For displaying session key generate error
skey_generate_error:
    push eax
    mov eax, skey_generate_fail
    call message_box
    pop eax
    jmp close_program

; For displaying session key acquire error
skey_acquire_error:
    push eax
    mov eax, skey_acquire_fail
    call message_box
    pop eax
    jmp close_program

; For displaying encryption error
encryption_error:
    ; Call GetLastError to retrieve the error code
    call [GetLastError]
    push eax
    mov eax, encryption_fail
    call message_box
    pop eax
    jmp close_program

; For displaying encryption error
user_key_error:
    ; Call GetLastError to retrieve the error code
    call [GetLastError]
    push eax
    mov eax, user_key_fail
    call message_box
    pop eax
    jmp close_program

; For displaying file open errors
file_open_error:
    push eax
    mov eax, file_open_fail
    call message_box
    pop eax
    jmp close_program

get_user_key:
    ; Acquiring user key
    lea eax, [hXchgKey]             ; hXchgKey
    push eax                        ; phUserKey: pointer to a handle of user key pair
    push 1             ; dwKeySpec: AT_KEYEXCHANGE = 1
    push [hProv]                      ; hProv: provider handle
    call [CryptGetUserKey]

    test eax, eax             ; Check if the call was successful
    jz user_key_error    ; If the result was non-zero, it was successful

    jmp export_key

export_key:
    ; Determine the size of the blob needed
    lea eax, [key_blob_size]
    push eax               ; pdwDataLen
    push 0                 ; pbData set to 0 for this dummy call
    push 0                 ; dwFlags
    push 0x00000001               ; dwBlobType. PRIVATEKEYBLOB = 0x00000003 , SIMPLEBLOB = 0x00000001
    push [hXchgKey]        ; hExpKey
    push [hKey]            ; hKey
    call [CryptExportKey]

    test eax, eax          ; Test if CryptExportKey succeeded
    jz encryption_error    ; If not, jump to error handling

    ; Allocate memory for the blob based on the determined size
    push [key_blob_size]
    push 0x0000 ; GMEM_FIXED
    call [GlobalAlloc]
    mov [key_blob], eax

    ; Check if memory allocation was successful
    test eax, eax                       ; ERROR_INVALID_HANDLE = 6, 0 = Failed
    jz encryption_error

    ; Now actually export the session key
    lea eax, [key_blob_size]
    push eax   ; pdwDataLen
    lea eax, [key_blob]
    push eax               ; pbData
    push 0                 ; dwFlags
    push 0x00000001        ; SIMPLEBLOB = 0x00000001
    push [hXchgKey]        ; hExpKey
    push [hKey]            ; hKey
    call [CryptExportKey]

    test eax, eax          ; Test if CryptExportKey succeeded
    jz encryption_error    ; If not, jump to error handling

    ; Open the key file for writing
    push 0
    push 0
    push 2                   ; CREATE_ALWAYS
    push 0
    push 0
    push 0C0000000h
    push key_file
    call [CreateFileA]
    mov [key_file_handle], eax

    ; Check if the handle is valid
    cmp eax, -1
    je file_open_error

    ; Write the exported key to the file
    push 0
    push bytes_written
    push [key_blob_size]
    push key_blob
    push [key_file_handle]
    call [WriteFile]

    ; Close the key file
    push [key_file_handle]
    call [CloseHandle]

    ; release memory for blob
    push [key_blob]
    call [GlobalFree]

    ; Destroy the hXchgKey after usage
    push [hXchgKey]
    call [CryptDestroyKey]

    ret

section '.idata' import data readable
    library advapi32, 'advapi32.dll', \
            kernel32, 'kernel32.dll', \
            user32, 'user32.dll'
  
    import advapi32, \
            CryptAcquireContextA, 'CryptAcquireContextA', \
            CryptGenKey, 'CryptGenKey', \
            CryptEncrypt, 'CryptEncrypt', \
            CryptDecrypt, 'CryptDecrypt', \
            CryptExportKey, 'CryptExportKey', \
            CryptGetUserKey, 'CryptGetUserKey', \
            CryptDestroyKey, 'CryptDestroyKey', \
            CryptReleaseContext, 'CryptReleaseContext'
  
    import kernel32, \
        ExitProcess, 'ExitProcess', \
        GetStdHandle, 'GetStdHandle', \
        WriteConsoleA, 'WriteConsoleA', \
        ReadConsoleA, 'ReadConsoleA', \
        CreateFileA, 'CreateFileA', \
        ReadFile, 'ReadFile', \
        WriteFile, 'WriteFile', \
        GetLastError, 'GetLastError', \
        GlobalAlloc, 'GlobalAlloc', \
        GlobalFree, 'GlobalFree', \
        CloseHandle, 'CloseHandle'
    
    import user32, \
       MessageBoxA, 'MessageBoxA'