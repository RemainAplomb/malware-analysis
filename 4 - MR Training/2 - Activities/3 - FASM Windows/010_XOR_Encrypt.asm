format PE Console
entry main

include 'win32a.inc'

section '.data' data readable writeable
    mbox_title db "Notification", 0                                 ; Title of the messagebox
    original_string db "Qljkyn+gm`", 0
    iterations = $ - original_string
    static_key db 0x55, 0xAA, 0x33, 0x77, 0x88, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x99, 0x66, 0x44, 0x22, 0x00, 0x11
    dec_key db 2, 4, 6, 8, 10, 9, 7, 5, 3, 1, 12, 14, 16, 15, 13, 11
    encrypted_string db 260 dup (0)   ; Placeholder for encrypted string
    decrypted_string db 260 dup (0)   ; Placeholder for encrypted string
    newline db 13, 10, 0
    ;iterations dd 22       ; Number of iterations/bytes/characters to encrypt
    msg_original_string_len db "Original String Length: ", 0
    msg_encrypted_string db "Encrypted String: ", 0

    message_file db "encrypted_text.txt", 0
    message_file_handle dd ?
    bytes_read dd ?
    bytes_written dd ?

    stdout dd ?

section '.code' code readable executable
main:
    ; Initialize stdout and stdin
    push -11                                                        ; STD_OUTPUT_HANDLE = -11
    call [GetStdHandle]
    mov [stdout], eax

    mov edx, original_string

    ; Loop through the specified number of iterations
    xor edi, edi            ; Clear edi (index) register
.loop:
    ;cmp edi, iterations   ; Compare current iteration with the specified number
    ;jge .done               ; Jump to done if iterations are completed

    ; Encrypt the character using XOR with the static key
    mov al, [edx + edi] ; Load a character from the original string

    cmp al, 0                       ; Check for null terminator
    je .done                ; Jump to done if null terminator is reached

    ; Calculate the corresponding index in the static key array
    mov ebx, edi
    and ebx, 0Fh            ; Mask with 15 to get the index within 0-15 range

    ; Encrypt the character
    mov bl, [dec_key + ebx] ; Load the corresponding byte from the static key
    xor al, bl              ; XOR the character with the key byte
    mov [edx + edi], al ; Store the encrypted character in the encrypted string

    inc edi                 ; Move to the next iteration
    jmp .loop               ; Repeat the loop

.done:
    ; Print the original and encrypted strings
    push 0                                                          ; Type of message box: MB_OK
    push mbox_title
    push original_string
    push 0                                                          ; Handle to owner window
    call [MessageBoxA]

    ; Create/Open Target file
    ; Open the file, read its content into a buffer
    push 0                                                          ; hTemplateFile
    push 0                                                          ; dwFlagsAndAttributes
    push 2                                                          ; dwCreationDisposition
    push 0                                                          ; lpSecurityAttributes
    push 0                                                          ; dwShareMode
    push 0C0000000h                                                 ; dwDesiredAccess
    push message_file                                                ; lpFileName - File to be opened
    call [CreateFileA]                                              ; CreateFileA function will return FileHandle in eax
    mov [message_file_handle], eax                                   ; Store file handle


    ; Write message to text file
    push 0                                                          ; lpOverlapped
    push bytes_written                                              ; lpNumberOfBytesWritten    
    push iterations                                               ; nNumberOfBytesToWrite
    push original_string                                                     ; lpBuffer
    push [message_file_handle]                                       ; file handle
    call [WriteFile]

    ; Close file handle
    push [message_file_handle]
    call [CloseHandle]

    mov edx, original_string

    ; Loop through the specified number of iterations
    xor edi, edi            ; Clear edi (index) register

.loop2:
    ;cmp edi, iterations   ; Compare current iteration with the specified number
    ;jge close_program               ; Jump to done if iterations are completed

    ; Encrypt the character using XOR with the static key
    mov al, [edx + edi] ; Load a character from the original string

    cmp al, 0                       ; Check for null terminator
    je close_program                ; Jump to done if null terminator is reached

    ; Calculate the corresponding index in the static key array
    mov ebx, edi
    and ebx, 0Fh            ; Mask with 15 to get the index within 0-15 range

    ; Encrypt the character
    mov bl, [dec_key + ebx] ; Load the corresponding byte from the static key
    xor al, bl              ; XOR the character with the key byte
    mov [edx + edi], al ; Store the encrypted character in the encrypted string

    inc edi                 ; Move to the next iteration
    jmp .loop2               ; Repeat the loop

close_program:
    ; Print the original and encrypted strings
    push 0                                                          ; Type of message box: MB_OK
    push mbox_title
    push original_string
    push 0                                                          ; Handle to owner window
    call [MessageBoxA]

    invoke  ExitProcess, 0

section '.idata' import data readable
    library advapi32, 'advapi32.dll', \
            kernel32, 'kernel32.dll', \
            user32, 'user32.dll'
  
    import advapi32, \
            CryptAcquireContextA, 'CryptAcquireContextA', \
            CryptCreateHash, 'CryptCreateHash', \
            CryptHashData, 'CryptHashData', \
            CryptDeriveKey, 'CryptDeriveKey', \
            CryptEncrypt, 'CryptEncrypt', \
            CryptDestroyKey, 'CryptDestroyKey', \
            CryptDestroyHash, 'CryptDestroyHash', \
            CryptReleaseContext, 'CryptReleaseContext'
  
    import kernel32, \
        ExitProcess, 'ExitProcess', \
        GetStdHandle, 'GetStdHandle', \
        WriteConsoleA, 'WriteConsoleA', \
        ReadConsoleA, 'ReadConsoleA', \
        CreateFileA, 'CreateFileA', \
        ReadFile, 'ReadFile', \
        WriteFile, 'WriteFile', \
        GlobalAlloc, 'GlobalAlloc', \
        GetFileSize, 'GetFileSize', \
        FindFirstFileA, 'FindFirstFileA', \
        FindNextFileA, 'FindNextFileA', \
        lstrcpyA, 'lstrcpyA', \
        CloseHandle, 'CloseHandle'
    
    import user32, \
       MessageBoxA, 'MessageBoxA'
