format PE Console
entry start

include 'win32ax.inc'

; Data section
section '.data' data readable writeable

    prompt_msg db "Enter a number: ", 0
    prompt_len = $ - prompt_msg

    MAX_BUFFER_SIZE equ 11 ; 10 digits max for 32-bit integer + null terminator
    buffer db MAX_BUFFER_SIZE dup(0)
    buffer_size = MAX_BUFFER_SIZE

    error_msg db "Not a valid integer!", 0

    bytes_read dd ?
    bytes_written dd ?
    number dd ?  ; To store the converted integer

    stdout dd ?                         ; Will contain the handler for stdout
    stdin dd ?                          ; Will contain the handler for stdin

; Code section
section '.text' code readable executable

start:
    ; Initialize stdout and stdin
    invoke GetStdHandle, STD_OUTPUT_HANDLE
    mov [stdout], eax
    invoke GetStdHandle, STD_INPUT_HANDLE
    mov [stdin], eax

    ; Prompt user for input
    invoke WriteConsoleA, [stdout], prompt_msg, prompt_len, bytes_written, 0
    invoke ReadConsoleA, [stdin], buffer, buffer_size, bytes_read, 0

    ; Call the function to strip leading and trailing white spaces
    call strip_whitespaces

    ; Convert string to integer
    call str2int
    jc .error   ; Jump to error if the conversion fails

    ; Example operation: add 10 to the integer
    add [number], 10

    ; Convert integer back to string
    lea edx, [buffer]
    call int2str

    ; Display the new string
    lea edx, [buffer]
    call compute_length   ; EAX now contains the length of the string in the buffer
    invoke WriteConsoleA, [stdout], buffer, eax, bytes_written, 0
    jmp .exit

.error:
    ; Display error message
    lea edx, [error_msg]
    call compute_length   ; EAX now contains the length of the string in the buffer
    invoke WriteConsoleA, [stdout], error_msg, eax, bytes_written, 0

.exit:
    push 0
    call [ReadConsoleA] ; Read a character to pause
    add esp, 20h ; Clean up the stack (5 dwords * 4 = 20h)
    invoke ExitProcess, 0

; Function to convert string to integer
; Expects: EDX pointing to the string
; Returns: number in 'number' variable, carry flag set if conversion failed
str2int:
    xor eax, eax  ; Clear EAX which will store our number
    xor ecx, ecx  ; Clear ECX which will be our multiplier for position value
    cld           ; Clear direction flag, process string left-to-right

.next_digit:
    lodsb          ; Load byte at DS:EDX into AL, and increment EDX
    test al, al    ; Check if it's the null terminator
    jz .done       ; If yes, we're done

    ; Check if character is a digit
    sub al, '0'    ; Convert char to integer
    jb .fail       ; If below '0', not a valid character
    cmp al, 9
    ja .fail       ; If above 9, not a valid character

    ; Accumulate result
    imul ecx, eax, 10     ; Multiply current result by 10 (shift left by one decimal place)
    add eax, ecx          ; Add the old value (multiplied by 10)
    movzx eax, al         ; Zero-extend AL to EAX
    add [number], eax     ; Add the new digit
    jmp .next_digit

    jmp .next_digit

.fail:
    stc  ; Set carry flag to indicate failure
    ret

.done:
    mov [number], eax ; Store the final result
    clc               ; Clear carry flag to indicate success
    ret

; Function to convert integer to string
; Expects: EAX contains integer
; Returns: EDX pointing to the start of the string
int2str:
    push ebx
    push ecx
    mov ecx, 10   ; Base 10 for our conversion

    ; Calculate end of buffer to work backwards
    lea ebx, [buffer + buffer_size - 1]
    mov byte [ebx], 0  ; Null-terminate the string

.reverse_loop:
    dec ebx
    xor edx, edx        ; Clear any previous remainder
    div ecx             ; Divide EAX by 10, result in EAX, remainder in EDX
    add dl, '0'         ; Convert to ASCII
    mov [ebx], dl       ; Store at current position

    test eax, eax       ; Check if quotient is zero
    jnz .reverse_loop   ; If not, continue loop

    mov edx, ebx        ; Point to the start of the generated string
    pop ecx
    pop ebx
    ret

; Function to compute length of buffer until sentinel (0 in this case)
; Expects: EDX pointing to the buffer
; Returns: EAX containing the length (excluding sentinel)
compute_length:
    lea edi, [edx]
    xor eax, eax ; Clear EAX, which will count the characters
    .loop:

        cmp byte [edi], 0
        je .done
        inc edi
        inc eax
        jmp .loop 
    .done:
        ret

; Function to strip leading and trailing white spaces (spaces, tabs, CR, LF)
; strip whitespace -> strip leading whitespace -> 
strip_whitespaces:
    lea esi, [buffer]         ; Use register esi as pointer for the leading whitespace loop
    lea edi, [buffer]         ; Use register edi as pointer for the trailing whitespace loop

.skip_leading:
    ; Check for white space characters at the beginning
    cmp byte [esi], ' '             ; Space. Check if current byte pointed by esi is a whitespace
    je .skip_char                   ; If it is whitespace, go to .skip_char so that we will not copy it to the eax
    cmp byte [esi], 9               ; tab
    je .skip_char
    cmp byte [esi], 10              ; LF
    je .skip_char
    cmp byte [esi], 13              ; CR
    je .skip_char
    jmp .copy_chars                 ; If current byte is not whitespace, we have found the start of string

.skip_char:
    ; Move to the next character
    inc esi                         ; If whitespace, increment to the next byte
    dec [bytes_read]                ; Subtract number of bytes from bytes_read. 
    jmp .skip_leading               ; Go back to the skip leading loop

.copy_chars:
    ; Copy characters from esi to edi until a null byte is encountered
    movzx eax, byte [esi]           ; Copy the value of the current byte pointed by esi
    test eax, eax                   ; Check whether it is not the Null terminator
    jz .end_of_string               ; If null terminator, go to .end_of_string
    mov [edi], al                   ; Overwrite the leading whitespace character byte with a non-white space character
    inc edi                         ; Increment the edi counter to point to the next byte
    inc esi                         ; Increment the edi counter to point to the next byte
    jmp .copy_chars                 ; Keep the loop going to copy the entire string

.end_of_string:
    ; Append null terminator
    mov [edi], al                   ; Append/copy/move the null-terminator to the end of the string

    ; Now, let's strip trailing whitespaces
    dec edi                         ; Decrement to point to the byte before the null-terminator

.strip_trailing:
    ; Check for white space characters at the end
    cmp byte [edi], ' '             ; space. IF whitespace, go to .strip_trailing_char
    je .strip_trailing_char
    cmp byte [edi], 9               ; tab
    je .strip_trailing_char
    cmp byte [edi], 10              ; LF
    je .strip_trailing_char
    cmp byte [edi], 13              ; CR
    je .strip_trailing_char
    ret                             ; If found non-whitespace character, end the loop

.strip_trailing_char:
    ; Replace character with null
    mov byte [edi], 0               ; Overwrite current byte pointed by edi to 0
    dec [bytes_read]                ; Subtract bytes_read by 1 because we have removed a whitespace
    dec edi                         ; Decrement to point to the byte before the current byte
    jmp .strip_trailing             ; Go back to loop

; Import section
section '.idata' data readable import
    library kernel32, 'kernel32.dll'

    import kernel32, \
        GetStdHandle, 'GetStdHandle', \
        WriteConsoleA, 'WriteConsoleA', \
        ReadConsoleA, 'ReadConsoleA', \
        ExitProcess, 'ExitProcess'
