; Bubble Sort Program in FASM for sorting an array of integers

format ELF executable 3             ; Use the ELF format for Unix/Linux executables.
entry main                         ; Define the program entry point

; DATA SEGMENT
segment readable writeable
    input_data db 100 dup(0)       ; Buffer to store user input.
    prompt_message db "Please enter 5 numbers: ", 0xA
    result_message db "Sorted numbers in ascending order: ", 0xA
    numbers dd 5 dup(0)            ; Array to store 5 integers.
    num_count dd 5                 ; Number of integers to sort.

    str_buffer db 11 dup(0)          ; For storing converted number. 10 characters + null terminator.
    space_message db ' ', 0
    newline_message db 0xA, 0

; CODE SEGMENT
segment readable executable
main:
    CALL ask_user
    CALL cin
    CALL parse_input               ; Convert string input to array of integers.
    CALL bubble_sort              ; Sort the array.
    CALL print_result
    JMP terminate_program

ask_user:
    ; Prompt the user to enter 5 numbers.
    MOV ecx, prompt_message
    CALL print
    RET

parse_input:
    ; Initialize registers
    MOV esi, input_data          ; Point to the start of the input_data string
    MOV edi, numbers             ; Point to the start of the numbers array
    XOR eax, eax                 ; Clear eax, which will accumulate the integer value
    XOR ebx, ebx                 ; ebx will serve as our base multiplier (units, tens, hundreds, etc.)

parse_loop:
    ; Fetch the current character
    MOVZX edx, byte [esi]       ; Load the byte at esi into edx

    ; Check if we hit a null terminator
    TEST edx, edx
    JZ save_last_number

    ; Check if the character is a digit
    CMP edx, '0'
    JL check_space
    CMP edx, '9'
    JG check_space

    ; It's a digit: convert from ASCII to integer and accumulate
    SUB edx, '0'                ; Convert ASCII to integer
    IMUL eax, eax, 10           ; Multiply accumulated value by 10
    ADD eax, edx                ; Add new digit to accumulated value
    INC esi                     ; Move to next character
    JMP parse_loop

check_space:
    ; Check if it's a space
    CMP edx, ' '
    JNE done_parsing            ; If it's neither a digit nor space, likely an error or unexpected char

    ; Store the number accumulated in eax to the numbers array
    MOV [edi], eax
    ADD edi, 4                  ; Point to next slot in the numbers array

    ; Reset accumulator and move to next character
    XOR eax, eax
    INC esi
    JMP parse_loop

save_last_number:
    ; Handle the last number (not necessarily followed by a space)
    TEST eax, eax
    JZ done_parsing             ; If the accumulator is zero, skip
    MOV [edi], eax              ; Otherwise, store the last number

done_parsing:
    RET

bubble_sort:
    ; Implement the bubble sort algorithm.
    MOV ecx, num_count            ; ECX will serve as our outer loop counter.

outer_loop:
    DEC ecx
    JZ done_sorting               ; If ECX is zero, sorting is done.
    MOV ebx, 0                    ; EBX will serve as our inner loop counter.

inner_loop:
    ; Compare numbers[EBX] and numbers[EBX + 1].
    MOV eax, [numbers + ebx*4]
    MOV edx, [numbers + ebx*4 + 4]
    CMP eax, edx
    JLE no_swap

    ; Swap the numbers.
    MOV [numbers + ebx*4], edx
    MOV [numbers + ebx*4 + 4], eax

no_swap:
    INC ebx                       ; Move to the next pair.
    CMP ebx, ecx                  ; Check if we reached the end of this pass.
    JL inner_loop

    ; Start the next pass.
    JMP outer_loop

done_sorting:
    RET

print_result:
    ; Point to the result message and print it
    MOV ecx, result_message
    CALL print

    ; Initialize our number array pointer
    MOV edi, numbers

    ; Loop through the numbers
    MOV ecx, 5                  ; Total numbers to be printed

print_numbers_loop:
    ; Convert the number at edi to its string representation
    MOV eax, [edi]              ; Load the current number
    CALL int_to_string          ; eax contains number, result is stored in a buffer

    ; Print the number string
    MOV ecx, str_buffer         ; Point to the string buffer
    CALL print

    ; Print a space
    MOV ecx, space_message
    CALL print

    ADD edi, 4                  ; Move to the next number in the array
    LOOP print_numbers_loop     ; Decrement ecx and loop if not zero

    ; Print a newline
    MOV ecx, newline_message
    CALL print
    RET

terminate_program:
    ; End the program.
    MOV eax, 1
    XOR ebx, ebx
    INT 0x80

cin:
    ; Read from stdin and store in input_data.
    MOV eax, 3
    MOV ebx, 0
    MOV ecx, input_data
    MOV edx, 100
    INT 0x80
    RET

print:
    ; Display a message.
    MOV eax, 4
    MOV ebx, 1
    MOV edx, [ecx-4]               ; Assume the message's length is stored just before the message.
    INT 0x80
    RET

int_to_string:
    ; Convert integer in eax to a string.
    ; Stores result in str_buffer.
    ; This routine does not handle negative numbers or zero.
    ; Assumes a maximum of 10 digits in the integer.

    MOV edi, str_buffer + 10     ; Start from the end of the buffer
    MOV byte [edi], 0            ; Null terminate
    DEC edi                      ; Move one position up

convert_loop:
    ; Extract the least significant digit
    XOR edx, edx                 ; Clear edx for division
    MOV ebx, 10                  ; Set divisor
    DIV ebx                      ; Divide eax by 10, result in eax, remainder in edx

    ; Convert the digit to ASCII
    ADD dl, '0'
    MOV [edi], dl

    DEC edi                      ; Move to the next position
    TEST eax, eax                ; Check if there are more digits
    JNZ convert_loop             ; If yes, continue extracting

    ; Point to the start of the number string
    MOV edi, str_buffer

find_start:
    ; Check if it's a non-null character
    TEST byte [edi], 0xFF
    JZ  skip_position
    ; If non-null, exit loop (start of number found)
    RET

skip_position:
    INC edi                      ; Move to the next character
    JMP find_start
