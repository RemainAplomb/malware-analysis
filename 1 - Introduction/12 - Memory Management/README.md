# Memory Management

## Overview

Memory management is a crucial concept in low-level languages such as Assembly. Here, programmers are directly responsible for managing memory, which includes allocating, deallocating, and addressing it correctly. Proper memory management is key to efficient and bug-free programs. Mismanagement can lead to issues like memory leaks (not deallocating memory that is no longer needed) and segmentation faults (accessing a memory location that wasn't allocated to your program).

While memory management in Assembly can be more complex than in higher-level languages, it also offers greater control and efficiency. Understanding how to manipulate the stack and heap and how to effectively use different addressing modes is crucial to being an effective Assembly programmer.

## Stack

The stack is a region of memory used for static memory allocation and deallocation. It's managed implicitly by the CPU and grows and shrinks automatically as functions push and pop data. The stack is used to store local variables and function call information.

Here's a basic example of how local variables can be managed on the stack in Assembly:

```
section .text
global _start

_start:
    push ebp           ; Save the old base pointer value
    mov ebp, esp       ; Set the new base pointer value
    sub esp, 4         ; Allocate 4 bytes on the stack for the local variable
    mov [ebp-4], 10    ; Set the value of the local variable to 10
    ; other instructions...
    mov esp, ebp       ; Deallocate local variables
    pop ebp            ; Restore the old base pointer value
    ; other instructions...
```

This example creates a local variable by subtracting from the stack pointer (esp). The local variable is then addressed relative to the base pointer (ebp).

## Heap

Unlike the stack, the heap is used for dynamic memory allocation and deallocation. It must be managed explicitly by the programmer. The brk and sbrk system calls can be used to allocate and deallocate memory on the heap.

Here's an example of how you can allocate and deallocate memory on the heap:

```
section .data
size equ 100 ; Size of the memory block to allocate

section .text
global _start

_start:
    mov eax, 45    ; System call number (sys_brk)
    xor ebx, ebx   ; Set the program break to the end of the data segment (allocate no memory)
    int 0x80       ; Call kernel
    mov esi, eax   ; Save the current program break

    add esi, size  ; Calculate the new program break
    mov eax, 45    ; System call number (sys_brk)
    mov ebx, esi   ; New program break
    int 0x80       ; Call kernel
    ; eax now contains the start of the allocated memory block, or 0 if the allocation failed

    ; other instructions...

    ; Deallocate the memory block before exiting:
    mov eax, 45    ; System call number (sys_brk)
    sub ebx, size  ; Original program break
    int 0x80       ; Call kernel

```

In this example, the sys_brk system call is used to change the program break (the end of the program's data segment), effectively allocating or deallocating memory on the heap.

## Memory Addressing Modes

Assembly supports several addressing modes, which determine how the operands of an instruction are accessed. Here are the most common ones:

Immediate mode: The operand is a constant value. For example, mov eax, 10.

Register mode: The operand is a register. For example, mov eax, ebx.

Direct mode: The operand is a memory location. For example, mov eax, [label].

Indirect mode: The operand is a memory location, but the address is stored in a register. For example, mov eax, [ebx].

Indexed mode: The operand is a memory location, calculated by adding a constant value to a register. For example, mov eax, [ebx + 4].

Base-Indexed mode: The operand is a memory location, calculated by adding the contents of two registers. For example, mov eax, [ebx + ecx].

Understanding and effectively using these addressing modes is a key part of memory management in Assembly.
