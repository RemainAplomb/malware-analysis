# Numbers, Strings, and Arrays

## Overview

Assembly language is a low-level programming language that has a strong correspondence with the architecture's machine code instructions. It provides very direct and low-level access to a computer's resources. Understanding how to work with numbers, strings, and arrays in Assembly is fundamental to implementing more complex operations and algorithms. Though it might seem daunting at first, with practice, you can achieve a deeper understanding of computer systems by learning Assembly.

## Working with Numbers

In Assembly, numbers are usually manipulated using registers. The operation you can perform on numbers include addition (add), subtraction (sub), multiplication (mul), division (div), and bitwise operations like AND (and), OR (or), NOT (not), XOR (xor), as well as shift (shl, shr) and rotate (rol, ror) operations.

Here is a basic example:

```
mov eax, 5    ; Store the number 5 in the EAX register
mov ebx, 3    ; Store the number 3 in the EBX register
mul ebx       ; Multiply EAX by EBX, result is in EAX

```

Remember, division in Assembly is a bit more complex, with the dividend being a 64-bit value constructed from two registers (EDX:EAX), and the divisor being a 32-bit value. The quotient is stored in EAX and the remainder in EDX.

## Working with Strings

Assembly language handles strings as sequences of characters terminated by a null character (ASCII value 0). To print a string, you usually have to make a system call, which may vary depending on the operating system.

Here's a snippet for string printing in Linux:

```
section .data
message db 'Hello, World!', 0 ; Null-terminated string

section .text
global _start
_start:
    ; write syscall
    mov eax, 4
    mov ebx, 1
    mov ecx, message
    mov edx, 13
    int 0x80

    ; exit syscall
    mov eax, 1
    xor ebx, ebx
    int 0x80

```

## Working with Arrays

In Assembly, you can create an array of data elements in the .data section. To access individual elements, you need to calculate the offset from the beginning of the array. This typically involves multiplying the element's index by the size of each element.

Here's a simple example of declaring and accessing an array:

```
section .data
array dd 10, 20, 30, 40, 50 ; Declare an array of integers

section .text
global _start
_start:
    mov eax, [array + 4 * 2] ; Access the 3rd element (0-indexed) of the array
    ; EAX now holds the value 30

```

By understanding and mastering these low-level operations, you can have a much clearer idea of how higher-level constructs in languages like C or Python translate down to machine code.
