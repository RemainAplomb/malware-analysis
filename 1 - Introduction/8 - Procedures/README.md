# Procedures

## Overview

A procedure is a group of related instructions that perform a specific task. Procedures can be called from different parts of a program and can return a value to the calling program after completing their task. In assembly language, procedures are implemented using call and ret instructions.

Understanding procedures in Assembly language is crucial for creating structured, modular, and reusable code. The ability to divide complex tasks into smaller, manageable procedures simplifies development and makes code easier to understand and debug.

## Defining Procedures

A procedure is defined using a label, followed by a series of assembly instructions, and terminated with a ret (return) instruction.

Here's a basic example:

```
section .text
global _start

_start:
call procedure_name
; other instructions...

procedure_name:
; procedure code...
ret
```

Here's another example:

```
increment:
    add eax, 1
    ret
```

## Calling Procedures

To call a procedure, use the call instruction followed by the procedure's label. This instruction pushes the return address onto the stack and jumps to the procedure code. After the ret instruction is executed, control returns to the instruction following the call.

Here is an example of calling the increment procedure. The call instruction both jumps to the procedure and pushes the return address (the address of the instruction after call) onto the stack.

```
section .text
global _start

_start:
    mov eax, 5     ; Move 5 into the EAX register
    call increment ; Call the increment procedure
    ; Now, EAX holds the value 6
    ; other instructions...
```

## Procedure Stack

The stack is a Last In, First Out (LIFO) data structure that is used for storing information during a procedure call. The push instruction is used to place items on top of the stack, and the pop instruction removes items. It's essential to balance the stack, meaning that each push should be matched with a corresponding pop.

When calling procedures, it's important to ensure that any values you need after the procedure call are saved beforehand, as the procedure may overwrite them. This is done using the stack.

For example, if a procedure uses the ebx register, and you have important data in ebx, you should push ebx onto the stack before the procedure call, and pop it off afterward:

```
section .text
global _start

_start:
    mov ebx, 123   ; We need to preserve this value
    push ebx       ; Save EBX
    call procedure ; Call the procedure that uses (and alters) EBX
    pop ebx        ; Restore EBX to its original value
    ; Now, EBX still holds the value 123
    ; other instructions...

procedure:
    mov ebx, 1     ; Do something with EBX
    ret
```

## Parameter Passing

Parameters can be passed to procedures using registers, global variables, or the stack. The choice of method depends on the size and number of parameters, as well as the specific calling convention being used.

Here's an example of passing parameters using registers:

```
section .text
global _start

_start:
    mov eax, 5
    mov ebx, 7
    call add
    ; EAX now contains the result (12)

add:
    add eax, ebx
    ret
```

Here's an example of passing parameters via the stack:

```
section .text
global _start

_start:
    push 7     ; Second parameter
    push 5     ; First parameter
    call add   ; Call the add procedure
    add esp, 8 ; Clean up the stack
    ; EAX now contains the result (12)
    ; other instructions...

add:
    pop eax     ; Pop first parameter into EAX
    pop ebx     ; Pop second parameter into EBX
    add eax, ebx
    ret
```
