# Recursion

## Overview

In assembly language, recursion involves the repeated use of stack operations - push, pop, call, and ret - to save and restore state as you enter and exit recursive calls.

## Understanding Recursion

Let's take a simple mathematical example: factorial calculation. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. It is denoted by n!. It can be defined by the recursive formula: n! = n\*(n-1)!, with 0! = 1.

This is a classic example where recursion can be used as the problem can be broken down into smaller sub-problems.

## Implementing Recursion

Below is an implementation of a factorial calculation in Assembly language:

```
section .data

section .text
global _start

_start:
    mov eax, 5         ; Calculate 5!
    call factorial     ; EAX now holds the result (120)
    ; other instructions...

factorial:
    cmp eax, 1         ; Base case: if N is 1 or 0, return 1
    jle end_factorial  ; If condition is met, jump to end_factorial
    dec eax            ; Decrease N by 1 (for next recursive call)
    push eax           ; Save the current N on the stack
    call factorial     ; Recursive call with N-1
    pop ebx            ; Retrieve the original N value from stack
    imul eax, ebx      ; Multiply the returned value by the original N
end_factorial:
    mov eax, 1         ; If base case is met, return 1
    ret
```

## Recursion Limitations

While recursion can make code appear neat and elegant, it does have its drawbacks. Recursive procedures can be more space-inefficient and slower compared to iterative versions due to the overhead of repeated procedure calls and stack operations.

It's also worth mentioning that you must take care not to cause a stack overflow by causing too deep of a recursion.

## Example: Fibonacci Series

The Fibonacci series is a sequence of numbers in which each number after the first two is the sum of the two preceding ones. It can be defined as: F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. Here's how you could implement it using recursion:

```
section .data

section .text
global _start

_start:
    mov eax, 9         ; Calculate the 9th Fibonacci number
    call fibonacci     ; EAX now holds the result (34)
    ; other instructions...

fibonacci:
    cmp eax, 2         ; If N < 2, return N as base case
    jl end_fibonacci   ; If condition is met, jump to end_fibonacci
    push eax           ; Save the current N on the stack
    dec eax            ; Decrease N by 1 for the first recursive call
    call fibonacci     ; Recursive call with N-1
    push eax           ; Save the result on the stack
    pop ebx            ; Move the first result into EBX
    dec ebx            ; Decrease N by 1 again for the second recursive call
    call fibonacci     ; Recursive call with N-2
    pop ecx            ; Retrieve the first result from the stack
    add eax, ecx       ; Add the two results together
end_fibonacci:
    ret
```

## Example: Greatest Common Divisor (GCD)

The greatest common divisor (GCD) of two integers can be found using Euclid's algorithm, which can be implemented recursively. The algorithm states: gcd(a, 0) = a and gcd(a, b) = gcd(b, a mod b).

```
section .data

section .text
global _start

_start:
    mov eax, 48        ; First number
    mov ebx, 18        ; Second number
    call gcd           ; EAX now holds the result (6)
    ; other instructions...

gcd:
    cmp ebx, 0         ; If B = 0, return A (base case)
    je end_gcd         ; If condition is met, jump to end_gcd
    push eax           ; Save the current A on the stack
    push ebx           ; Save the current B on the stack
    xor edx, edx       ; Clear EDX (needed for division)
    idiv ebx           ; Divide A by B, quotient in EAX, remainder in EDX
    mov eax, ebx       ; Move B to A for the next recursive call
    mov ebx, edx       ; Move the remainder to B for the next recursive call
    call gcd           ; Recursive call
    pop ebx            ; Restore the original B value
    pop eax            ; Restore the original A value
end_gcd:
    ret
```
